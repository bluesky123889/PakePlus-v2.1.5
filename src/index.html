<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>俄罗斯方块 - 多模式游戏</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            padding: 20px;
            overflow-x: hidden;
        }
        
        /* 语言选择器样式 - 移到设置中 */
        .language-selector {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        
        .lang-btn {
            padding: 6px 12px;
            background: rgba(40, 40, 70, 0.8);
            color: #a0a0c0;
            border: 1px solid #2a2a4a;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
            min-width: 60px;
            text-align: center;
            flex: 1;
        }
        
        .lang-btn:hover {
            background: rgba(60, 60, 90, 0.8);
            color: #fff;
        }
        
        .lang-btn.active {
            background: rgba(77, 204, 189, 0.3);
            color: #4dccbd;
            border-color: #4dccbd;
            box-shadow: 0 0 10px rgba(77, 204, 189, 0.3);
        }
        
        /* 左上角设置按钮区域 */
        .top-left-controls {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        .top-left-btn {
            padding: 10px 16px;
            background: rgba(40, 40, 70, 0.8);
            color: #a0a0c0;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            border: 1px solid #2a2a4a;
        }
        
        .top-left-btn:hover {
            background: rgba(60, 60, 90, 0.8);
            color: #fff;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        /* 设置面板样式 */
        #settingsPanel {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.5s ease;
        }
        
        .settings-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 2px solid #4dccbd;
            overflow-y: auto;
            position: relative;
        }
        
        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #2a2a4a;
        }
        
        .settings-header h2 {
            font-size: 1.8rem;
            color: #ff9966;
        }
        
        .close-settings {
            background: #ff5e62;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .close-settings:hover {
            background: #ff3b3f;
            transform: translateY(-2px);
        }
        
        .settings-options {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: rgba(40, 40, 70, 0.6);
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        
        .setting-item:hover {
            background: rgba(50, 50, 80, 0.8);
        }
        
        .setting-info {
            flex: 1;
        }
        
        .setting-title {
            font-size: 1.1rem;
            font-weight: bold;
            color: #fff;
            margin-bottom: 5px;
        }
        
        .setting-description {
            font-size: 0.9rem;
            color: #a0a0c0;
            line-height: 1.4;
        }
        
        /* 开关按钮样式 */
        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
            margin-left: 15px;
        }
        
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #2a2a4a;
            transition: .4s;
            border-radius: 34px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: #a0a0c0;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #4dccbd;
        }
        
        input:checked + .slider:before {
            transform: translateX(30px);
            background-color: white;
        }
        
        /* 音量滑块样式 */
        .volume-slider {
            width: 100px;
            margin-left: 15px;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #2a2a4a;
            border-radius: 3px;
            outline: none;
        }
        
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #4dccbd;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .volume-slider::-webkit-slider-thumb:hover {
            background: #3db8a8;
            transform: scale(1.1);
        }
        
        .volume-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #4dccbd;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .volume-value {
            min-width: 40px;
            text-align: center;
            color: #4dccbd;
            font-weight: bold;
            font-size: 0.9rem;
        }
        
        /* 右上角功能按钮区域 */
        .top-right-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        .top-right-btn {
            padding: 10px 16px;
            background: rgba(40, 40, 70, 0.8);
            color: #a0a0c0;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            border: 1px solid #2a2a4a;
        }
        
        .top-right-btn:hover {
            background: rgba(60, 60, 90, 0.8);
            color: #fff;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        /* 排行榜面板样式 */
        #leaderboardPanel {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.5s ease;
        }
        
        .leaderboard-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 2px solid #4dccbd;
            overflow-y: auto;
            position: relative;
        }
        
        .leaderboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #2a2a4a;
        }
        
        .leaderboard-header h2 {
            font-size: 1.8rem;
            color: #ff9966;
        }
        
        .close-leaderboard {
            background: #ff5e62;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .close-leaderboard:hover {
            background: #ff3b3f;
            transform: translateY(-2px);
        }
        
        .leaderboard-tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid #2a2a4a;
        }
        
        .leaderboard-tab {
            padding: 10px 20px;
            background: none;
            color: #a0a0c0;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s ease;
            border-bottom: 3px solid transparent;
        }
        
        .leaderboard-tab.active {
            color: #4dccbd;
            border-bottom: 3px solid #4dccbd;
        }
        
        .leaderboard-tab:hover:not(.active) {
            color: #fff;
        }
        
        .leaderboard-list {
            list-style-type: none;
            padding-left: 0;
        }
        
        .leaderboard-item {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            margin-bottom: 10px;
            background: rgba(40, 40, 70, 0.6);
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        
        .leaderboard-item:hover {
            background: rgba(50, 50, 80, 0.8);
            transform: translateX(5px);
        }
        
        .leaderboard-rank {
            font-size: 1.3rem;
            font-weight: bold;
            color: #ff9966;
            width: 40px;
            text-align: center;
        }
        
        .leaderboard-info {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .leaderboard-name {
            font-size: 1.1rem;
            font-weight: bold;
            color: #fff;
            margin-bottom: 4px;
        }
        
        .leaderboard-score {
            font-size: 1rem;
            color: #4dccbd;
        }
        
        .leaderboard-date {
            font-size: 0.8rem;
            color: #a0a0c0;
        }
        
        .no-scores {
            text-align: center;
            padding: 30px;
            color: #a0a0c0;
            font-style: italic;
        }
        
        .clear-scores-btn {
            display: block;
            margin: 20px auto 0;
            padding: 10px 20px;
            background: rgba(255, 94, 98, 0.2);
            color: #ff5e62;
            border: 1px solid #ff5e62;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .clear-scores-btn:hover {
            background: rgba(255, 94, 98, 0.3);
            transform: translateY(-2px);
        }
        
        /* 控制说明面板样式 */
        #controlsPanel {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.5s ease;
        }
        
        .controls-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 2px solid #4dccbd;
            overflow-y: auto;
            position: relative;
        }
        
        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #2a2a4a;
        }
        
        .controls-header h2 {
            font-size: 1.8rem;
            color: #ff9966;
        }
        
        .close-controls {
            background: #ff5e62;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .close-controls:hover {
            background: #ff3b3f;
            transform: translateY(-2px);
        }
        
        .keyboard-controls-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .key-item-panel {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 12px;
            background-color: #2a2a4a;
            border-radius: 8px;
        }
        
        /* 挑战模式难度标记 */
        .difficulty-badge {
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .difficulty-easy {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
            border: 1px solid #4CAF50;
        }
        
        .difficulty-medium {
            background: rgba(255, 152, 0, 0.2);
            color: #FF9800;
            border: 1px solid #FF9800;
        }
        
        .difficulty-hard {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
            border: 1px solid #f44336;
        }
        
        .difficulty-expert {
            background: rgba(156, 39, 176, 0.2);
            color: #9C27B0;
            border: 1px solid #9C27B0;
        }
        
        /* 隐形模式遮罩 - 完全遮挡，只对下落方块有效 */
        .invisible-mask {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 50%; /* 覆盖底部10行 (20行的50%) */
            background: rgba(15, 17, 35, 1); /* 改为纯色完全不透明 */
            pointer-events: none;
            z-index: 5; /* 低于提示文字 */
            border-radius: 0 0 8px 8px;
            transform: translateY(100%); /* 从底部开始 */
        }
        
        /* 隐形模式分界线 - 紫色实线 */
        .invisible-divider {
            position: absolute;
            left: 0;
            width: 100%;
            height: 3px;
            background: #9C27B0;
            pointer-events: none;
            z-index: 6;
            box-shadow: 0 0 10px rgba(156, 39, 176, 0.7);
        }
        
        /* 行数提示特效 - 在遮罩上方显示 */
        .line-clear-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            font-weight: bold;
            color: #ff9966;
            text-shadow: 0 0 10px rgba(255, 153, 102, 0.7);
            pointer-events: none;
            z-index: 10; /* 高于遮罩 */
            opacity: 0;
            white-space: nowrap;
        }
        
        /* 分数增加特效 - 在遮罩上方显示 */
        .score-add-effect {
            position: absolute;
            font-size: 1.5rem;
            font-weight: bold;
            color: #4dccbd;
            text-shadow: 0 0 5px rgba(77, 204, 189, 0.7);
            pointer-events: none;
            z-index: 10; /* 高于遮罩 */
            opacity: 0;
        }
        
        /* 挑战模式进度条 */
        .challenge-progress {
            width: 100%;
            height: 8px;
            background: rgba(40, 40, 70, 0.6);
            border-radius: 4px;
            margin: 15px 0;
            overflow: hidden;
        }
        
        .challenge-progress-fill {
            height: 100%;
            background: linear-gradient(to right, #4CAF50, #4dccbd);
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        /* 冲刺模式进度显示 */
        .sprint-progress-container {
            background: rgba(40, 40, 70, 0.6);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        
        .sprint-progress-text {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: #a0a0c0;
            margin-bottom: 5px;
        }
        
        /* 马拉松模式进度显示 - 优化版 */
        .marathon-progress-container {
            background: rgba(40, 40, 70, 0.6);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        
        .marathon-progress-text {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: #a0a0c0;
            margin-bottom: 5px;
        }
        
        .marathon-stage-info {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            color: #4dccbd;
            margin-top: 5px;
        }
        
        /* 自定义弹窗样式 */
        .custom-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease;
        }
        
        .custom-modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            width: 90%;
            max-width: 400px;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.6);
            border: 2px solid #4dccbd;
            position: relative;
            animation: modalSlideUp 0.4s ease;
        }
        
        .custom-modal-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #2a2a4a;
        }
        
        .custom-modal-icon {
            font-size: 2rem;
            margin-right: 15px;
            color: #ff9966;
        }
        
        .custom-modal-title {
            font-size: 1.5rem;
            color: #ff9966;
            flex: 1;
        }
        
        .custom-modal-body {
            margin-bottom: 25px;
        }
        
        .custom-modal-text {
            color: #e0e0ff;
            font-size: 1.1rem;
            line-height: 1.5;
            margin-bottom: 15px;
        }
        
        .custom-modal-input {
            width: 100%;
            padding: 12px 16px;
            background: rgba(40, 40, 70, 0.8);
            border: 2px solid #2a2a4a;
            border-radius: 8px;
            color: #fff;
            font-size: 1rem;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }
        
        .custom-modal-input:focus {
            outline: none;
            border-color: #4dccbd;
            box-shadow: 0 0 0 2px rgba(77, 204, 189, 0.3);
        }
        
        .custom-modal-input::placeholder {
            color: #a0a0c0;
        }
        
        .custom-modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 15px;
        }
        
        .custom-modal-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
        }
        
        .custom-modal-btn-primary {
            background: linear-gradient(to right, #4CAF50, #45a049);
            color: white;
        }
        
        .custom-modal-btn-secondary {
            background: rgba(40, 40, 70, 0.8);
            color: #a0a0c0;
            border: 1px solid #2a2a4a;
        }
        
        .custom-modal-btn-danger {
            background: linear-gradient(to right, #ff5e62, #ff3b3f);
            color: white;
        }
        
        .custom-modal-btn-primary:hover {
            background: linear-gradient(to right, #45a049, #3d8b40);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .custom-modal-btn-secondary:hover {
            background: rgba(60, 60, 90, 0.8);
            color: #fff;
            transform: translateY(-2px);
        }
        
        .custom-modal-btn-danger:hover {
            background: linear-gradient(to right, #ff3b3f, #ff1c1f);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        /* 新增：禁用状态按钮样式 */
        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
        
        .pause-btn:disabled {
            background: linear-gradient(to right, #666, #555) !important;
            color: #888 !important;
        }
        
        .reset-btn:disabled {
            background: linear-gradient(to right, #666, #555) !important;
            color: #888 !important;
        }
        
        @keyframes modalSlideUp {
            from {
                opacity: 0;
                transform: translateY(30px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        /* 更新公告样式 */
        #updateNotice {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.5s ease;
        }
        
        .notice-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            width: 90%;
            max-width: 1100px;
            height: 80vh;
            border-radius: 16px;
            padding: 0;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 2px solid #4dccbd;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        /* 公告标题区域 */
        .notice-header-section {
            padding: 25px 30px;
            border-bottom: 2px solid #2a2a4a;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            flex-shrink: 0;
            z-index: 10;
            position: relative;
        }
        
        .notice-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .notice-header h2 {
            font-size: 2rem;
            color: #ff9966;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .close-notice {
            background: #ff5e62;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 20px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 11;
        }
        
        .close-notice:hover {
            background: #ff3b3f;
            transform: translateY(-2px);
        }
        
        .notice-subtitle {
            color: #a0a0c0;
            font-size: 1rem;
            margin-top: 5px;
        }
        
        /* 公告主体内容区域 */
        .notice-body-section {
            display: flex;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }
        
        /* 版本侧边栏 */
        .version-sidebar-container {
            flex: 0 0 250px;
            display: flex;
            flex-direction: column;
            background: rgba(30, 30, 60, 0.8);
            border-right: 2px solid #2a2a4a;
            overflow: hidden;
        }
        
        .sidebar-header {
            padding: 20px;
            border-bottom: 2px solid #2a2a4a;
            background: rgba(40, 40, 70, 0.8);
            flex-shrink: 0;
        }
        
        .sidebar-header h3 {
            font-size: 1.3rem;
            color: #ff9966;
            text-align: center;
        }
        
        .version-sidebar {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        /* 自定义滚动条样式 */
        .version-sidebar::-webkit-scrollbar {
            width: 8px;
        }
        
        .version-sidebar::-webkit-scrollbar-track {
            background: rgba(40, 40, 70, 0.3);
            border-radius: 4px;
        }
        
        .version-sidebar::-webkit-scrollbar-thumb {
            background: #4dccbd;
            border-radius: 4px;
        }
        
        .version-sidebar::-webkit-scrollbar-thumb:hover {
            background: #3db8a8;
        }
        
        .version-item {
            padding: 15px;
            background: rgba(40, 40, 70, 0.6);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 4px solid transparent;
            flex-shrink: 0;
        }
        
        .version-item:hover {
            background: rgba(50, 50, 80, 0.8);
            transform: translateX(5px);
        }
        
        .version-item.active {
            background: rgba(77, 204, 189, 0.2);
            border-left: 4px solid #4dccbd;
        }
        
        .version-number {
            font-size: 1.1rem;
            font-weight: bold;
            color: #4dccbd;
            margin-bottom: 5px;
        }
        
        .version-date-sidebar {
            font-size: 0.85rem;
            color: #a0a0c0;
        }
        
        .current-version {
            position: relative;
        }
        
        .current-version:after {
            content: "当前版本";
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ff9966;
            color: #1a1a2e;
            font-size: 0.7rem;
            font-weight: bold;
            padding: 2px 8px;
            border-radius: 4px;
        }
        
        /* 版本详情区域 */
        .version-detail-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: rgba(20, 20, 40, 0.6);
        }
        
        .detail-header {
            padding: 20px 30px;
            border-bottom: 2px solid #2a2a4a;
            background: rgba(30, 30, 60, 0.8);
            flex-shrink: 0;
        }
        
        .detail-header h3 {
            font-size: 1.5rem;
            color: #ff9966;
            margin-bottom: 5px;
        }
        
        .detail-header p {
            color: #a0a0c0;
            font-size: 0.9rem;
        }
        
        .version-detail-content {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
        }
        
        .version-detail-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .version-detail-content::-webkit-scrollbar-track {
            background: rgba(40, 40, 70, 0.3);
            border-radius: 4px;
        }
        
        .version-detail-content::-webkit-scrollbar-thumb {
            background: #4dccbd;
            border-radius: 4px;
        }
        
        .version-detail-content::-webkit-scrollbar-thumb:hover {
            background: #3db8a8;
        }
        
        .version-title {
            font-size: 2rem;
            color: #ff9966;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #2a2a4a;
        }
        
        .version-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(40, 40, 70, 0.4);
            border-radius: 8px;
        }
        
        .version-number-large {
            font-size: 1.4rem;
            font-weight: bold;
            color: #4dccbd;
            padding: 8px 16px;
            background: rgba(77, 204, 189, 0.1);
            border-radius: 6px;
        }
        
        .version-date-detail {
            color: #a0a0c0;
            font-size: 1rem;
        }
        
        .version-description {
            color: #a0a0c0;
            margin-bottom: 30px;
            line-height: 1.6;
            font-size: 1.1rem;
            padding: 15px;
            background: rgba(40, 40, 70, 0.3);
            border-radius: 8px;
        }
        
        .version-features {
            list-style-type: none;
            padding-left: 0;
            margin-top: 20px;
        }
        
        .version-features li {
            padding: 12px 0;
            padding-left: 35px;
            position: relative;
            color: #e0e0ff;
            line-height: 1.5;
            border-bottom: 1px solid rgba(42, 42, 74, 0.5);
        }
        
        .version-features li:last-child {
            border-bottom: none;
        }
        
        .version-features li:before {
            content: "✓";
            position: absolute;
            left: 0;
            color: #4CAF50;
            font-weight: bold;
            font-size: 1.1rem;
            background: rgba(76, 175, 80, 0.1);
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* 方块消除特效 */
        .clear-effect {
            position: absolute;
            pointer-events: none;
            z-index: 8;
        }
        
        .clear-particle {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: currentColor;
            pointer-events: none;
            opacity: 0.8;
        }
        
        .clear-line {
            position: absolute;
            height: 3px;
            background: linear-gradient(90deg, transparent, currentColor, transparent);
            pointer-events: none;
            opacity: 0.9;
            transform-origin: center;
        }
        
        /* 保存提示样式 */
        .save-notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(77, 204, 189, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            z-index: 2000;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            animation: slideDown 0.3s ease, fadeOut 0.3s ease 2.7s forwards;
        }
        
        .save-notification.error {
            background: rgba(255, 94, 98, 0.9);
        }
        
        @keyframes slideDown {
            from {
                top: -100px;
                opacity: 0;
            }
            to {
                top: 20px;
                opacity: 1;
            }
        }
        
        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
                visibility: hidden;
            }
        }
        
        /* 主菜单样式 */
        #mainMenu {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 1000px;
            width: 100%;
            text-align: center;
            animation: fadeIn 0.8s ease;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            width: 100%;
        }
        
        .header h1 {
            font-size: 3.5rem;
            margin-bottom: 10px;
            background: linear-gradient(to right, #ff5e62, #ff9966);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .header p {
            color: #a0a0c0;
            font-size: 1.2rem;
            max-width: 800px;
            line-height: 1.6;
            margin: 0 auto 15px;
        }
        
        .menu-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 25px;
            width: 100%;
            margin-bottom: 40px;
        }
        
        .menu-card {
            background: rgba(30, 30, 60, 0.8);
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            cursor: pointer;
            border: 2px solid transparent;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            min-height: 320px;
        }
        
        .menu-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4);
            border-color: #4dccbd;
        }
        
        .menu-icon {
            font-size: 3.5rem;
            margin-bottom: 20px;
            height: 80px;
            width: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(77, 204, 189, 0.1);
        }
        
        .menu-card h2 {
            font-size: 1.8rem;
            margin-bottom: 15px;
            color: #ff9966;
        }
        
        .menu-card p {
            color: #a0a0c0;
            line-height: 1.5;
            margin-bottom: 20px;
            flex-grow: 1;
        }
        
        .menu-btn {
            padding: 12px 30px;
            background: linear-gradient(to right, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: auto;
        }
        
        .menu-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        /* 游戏界面样式 */
        #gameScreen {
            display: none;
            max-width: 1100px;
            width: 100%;
            animation: fadeIn 0.8s ease;
        }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #2a2a4a;
        }
        
        .back-btn {
            padding: 10px 20px;
            background: rgba(40, 40, 70, 0.8);
            color: #a0a0c0;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .back-btn:hover {
            background: rgba(60, 60, 90, 0.8);
            color: #fff;
            transform: translateY(-3px);
        }
        
        .game-title {
            font-size: 2.2rem;
            background: linear-gradient(to right, #ff5e62, #ff9966);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .game-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            width: 100%;
            margin-bottom: 30px;
            position: relative;
        }
        
        .game-area {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            position: relative;
        }
        
        .next-piece-container {
            background: rgba(30, 30, 60, 0.8);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 140px;
        }
        
        .next-piece-title {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #ff9966;
            font-weight: bold;
            text-align: center;
            width: 100%;
            padding-bottom: 10px;
            border-bottom: 2px solid #2a2a4a;
        }
        
        .next-canvas {
            background-color: #0f1123;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 2px solid #2a2a4a;
        }
        
        .next-piece-name {
            font-size: 1.2rem;
            font-weight: bold;
            color: #4dccbd;
            text-align: center;
            padding: 8px 12px;
            background: rgba(77, 204, 189, 0.1);
            border-radius: 8px;
            width: 100%;
        }
        
        .game-board {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 17, 35, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 8px;
            z-index: 15;
        }
        
        .start-prompt {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .start-prompt h2 {
            font-size: 2.5rem;
            color: #ff9966;
            margin-bottom: 15px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .start-prompt p {
            font-size: 1.5rem;
            color: #4dccbd;
            margin-bottom: 10px;
            animation: pulse 1.5s infinite;
        }
        
        .countdown {
            font-size: 5rem;
            font-weight: bold;
            color: #ff5e62;
            text-shadow: 0 0 10px rgba(255, 94, 98, 0.5);
            animation: pulse 0.5s infinite alternate;
            margin: 20px 0;
        }
        
        canvas {
            background-color: #0f1123;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .game-info {
            background-color: rgba(30, 30, 60, 0.8);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            width: 320px;
        }
        
        .info-section {
            margin-bottom: 25px;
        }
        
        .info-title {
            font-size: 1.3rem;
            color: #ff9966;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #2a2a4a;
        }
        
        .info-content {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #2a2a4a;
        }
        
        .info-label {
            color: #a0a0c0;
            font-weight: 500;
        }
        
        .info-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4dccbd;
        }
        
        .controls-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }
        
        .control-btn {
            padding: 14px;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .pause-btn {
            background: linear-gradient(to right, #FF9800, #F57C00);
            color: white;
            grid-column: span 2;
        }
        
        .pause-btn.continue-btn {
            background: linear-gradient(to right, #4CAF50, #45a049);
        }
        
        .reset-btn {
            background: linear-gradient(to right, #2196F3, #0b7dda);
            color: white;
            grid-column: span 2;
        }
        
        .control-btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .game-status {
            font-size: 1.3rem;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            margin-top: 15px;
            font-weight: bold;
        }
        
        .status-ready {
            background-color: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }
        
        .status-playing {
            background-color: rgba(33, 150, 243, 0.2);
            color: #2196F3;
        }
        
        .status-paused {
            background-color: rgba(255, 152, 0, 0.2);
            color: #FF9800;
        }
        
        .status-gameover {
            background-color: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }
        
        .timer-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(40, 40, 70, 0.6);
            padding: 10px 15px;
            border-radius: 8px;
            margin-top: 15px;
        }
        
        .timer-label {
            color: #a0a0c0;
            font-weight: 500;
        }
        
        .timer-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #ff9966;
        }
        
        .timer-warning {
            color: #ff5e62;
            animation: pulse 1s infinite;
        }
        
        .footer {
            margin-top: 30px;
            text-align: center;
            color: #a0a0c0;
            font-size: 0.9rem;
        }
        
        /* 动画效果 */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
            100% { opacity: 1; transform: scale(1); }
        }
        
        @keyframes countdownPulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        /* 特效动画 */
        @keyframes particleExplode {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 0.9;
            }
            100% {
                transform: translate(var(--tx), var(--ty)) scale(0);
                opacity: 0;
            }
        }
        
        @keyframes lineClear {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }
            20% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1;
            }
            80% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1.5);
                opacity: 0;
            }
        }
        
        @keyframes scoreAdd {
            0% {
                transform: translateY(0);
                opacity: 1;
            }
            100% {
                transform: translateY(-30px);
                opacity: 0;
            }
        }
        
        @keyframes glowPulse {
            0%, 100% {
                box-shadow: 0 0 5px currentColor;
            }
            50% {
                box-shadow: 0 0 20px currentColor;
            }
        }
        
        /* 响应式设计 */
        @media (max-width: 900px) {
            .header h1 {
                font-size: 2.5rem;
            }
            
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            
            .game-area {
                flex-direction: column;
                align-items: center;
            }
            
            .next-piece-container {
                order: -1;
                margin-bottom: 20px;
                width: 100%;
                max-width: 400px;
            }
            
            .game-info {
                width: 100%;
                max-width: 400px;
            }
            
            .menu-container {
                grid-template-columns: 1fr;
            }
            
            .game-header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }
            
            .notice-content {
                width: 95%;
                max-width: 95%;
                height: 90vh;
            }
            
            .notice-header-section {
                padding: 15px 20px;
            }
            
            .notice-header h2 {
                font-size: 1.5rem;
            }
            
            .notice-body-section {
                flex-direction: column;
            }
            
            .version-sidebar-container {
                flex: none;
                height: 200px;
                border-right: none;
                border-bottom: 2px solid #2a2a4a;
            }
            
            .version-sidebar {
                flex-direction: row;
                overflow-x: auto;
                overflow-y: hidden;
                padding: 10px;
            }
            
            .version-item {
                min-width: 150px;
                text-align: center;
            }
            
            .sidebar-header {
                padding: 15px;
            }
            
            .detail-header {
                padding: 15px 20px;
            }
            
            .version-detail-content {
                padding: 20px;
            }
            
            .start-prompt h2 {
                font-size: 2rem;
            }
            
            .start-prompt p {
                font-size: 1.2rem;
            }
            
            .countdown {
                font-size: 4rem;
            }
            
            .top-left-controls,
            .top-right-controls {
                position: relative;
                top: 0;
                left: 0;
                right: 0;
                justify-content: center;
                margin-bottom: 20px;
                width: 100%;
                flex-wrap: wrap;
            }
            
            .custom-modal-content {
                max-width: 90%;
                padding: 20px;
            }
            
            .line-clear-notification {
                font-size: 2rem;
            }
            
            .menu-card {
                min-height: 280px;
            }
        }
        
        @media (max-width: 480px) {
            .game-area {
                width: 100%;
            }
            
            canvas {
                width: 100%;
                height: auto;
                max-width: 300px;
            }
            
            .next-canvas {
                width: 120px;
                height: 120px;
            }
            
            .game-header {
                flex-wrap: wrap;
            }
            
            .game-title {
                font-size: 1.8rem;
                order: -1;
                width: 100%;
                margin-bottom: 10px;
            }
            
            .controls-section {
                grid-template-columns: 1fr;
            }
            
            .pause-btn, .reset-btn {
                grid-column: span 1;
            }
            
            .top-left-controls,
            .top-right-controls {
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .version-item {
                min-width: 130px;
                padding: 10px;
            }
            
            .version-number {
                font-size: 1rem;
            }
            
            .notice-header h2 {
                font-size: 1.3rem;
            }
            
            .custom-modal-footer {
                flex-direction: column;
            }
            
            .custom-modal-btn {
                width: 100%;
            }
            
            .line-clear-notification {
                font-size: 1.8rem;
            }
            
            .menu-card {
                min-height: 250px;
                padding: 20px;
            }
            
            .menu-icon {
                font-size: 2.5rem;
                height: 60px;
                width: 60px;
            }
        }
    </style>
</head>
<body>
    <!-- 左上角设置按钮区域 -->
    <div class="top-left-controls" id="topLeftControls">
        <button id="settingsBtn" class="top-left-btn">⚙️ <span data-i18n="settings">游戏设置</span></button>
    </div>
    
    <!-- 右上角功能按钮区域 -->
    <div class="top-right-controls">
        <button id="controlsBtn" class="top-right-btn">🎮 <span data-i18n="controls">控制说明</span></button>
        <button id="leaderboardBtn" class="top-right-btn">🏆 <span data-i18n="leaderboard">排行榜</span></button>
        <button id="updatesBtn" class="top-right-btn">📢 <span data-i18n="updates">更新公告</span></button>
    </div>
    
    <!-- 设置面板 -->
    <div id="settingsPanel">
        <div class="settings-content">
            <div class="settings-header">
                <h2 data-i18n="settings">游戏设置</h2>
                <button class="close-settings" data-i18n="close">关闭</button>
            </div>
            <div class="settings-options">
                <div class="setting-item">
                    <div class="setting-info">
                        <div class="setting-title" data-i18n="previewTitle">方块预览显示</div>
                        <div class="setting-description" data-i18n="previewDesc">显示当前方块下落位置的预览</div>
                    </div>
                    <label class="switch">
                        <input type="checkbox" id="previewToggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                
                <div class="setting-item">
                    <div class="setting-info">
                        <div class="setting-title" data-i18n="heightlineTitle">高度指示线</div>
                        <div class="setting-description" data-i18n="heightlineDesc">显示当前方块堆积高度的参考线</div>
                    </div>
                    <label class="switch">
                        <input type="checkbox" id="heightlineToggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                
                <div class="setting-item">
                    <div class="setting-info">
                        <div class="setting-title" data-i18n="musicVolume">背景音乐音量</div>
                        <div class="setting-description" data-i18n="musicVolumeDesc">调整背景音乐的音量大小</div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="range" id="musicVolumeSlider" class="volume-slider" min="0" max="100" value="70">
                        <span id="musicVolumeValue" class="volume-value">70%</span>
                    </div>
                </div>
                
                <div class="setting-item">
                    <div class="setting-info">
                        <div class="setting-title" data-i18n="soundVolume">音效音量</div>
                        <div class="setting-description" data-i18n="soundVolumeDesc">调整游戏音效的音量大小</div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="range" id="soundVolumeSlider" class="volume-slider" min="0" max="100" value="80">
                        <span id="soundVolumeValue" class="volume-value">80%</span>
                    </div>
                </div>
                
                <div class="setting-item" style="flex-direction: column; align-items: flex-start;">
                    <div class="setting-info">
                        <div class="setting-title" data-i18n="languageSetting">界面语言</div>
                        <div class="setting-description" data-i18n="languageDesc">选择游戏界面显示的语言</div>
                    </div>
                    <div class="language-selector">
                        <button class="lang-btn active" data-lang="zh-CN">简体中文</button>
                        <button class="lang-btn" data-lang="zh-TW">繁體中文</button>
                        <button class="lang-btn" data-lang="en-US">English</button>
                        <button class="lang-btn" data-lang="ja-JP">日本語</button>
                    </div>
                </div>
                
                <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #2a2a4a;">
                    <div id="settingsNoteContainer" style="color: #a0a0c0; font-size: 0.9rem; line-height: 1.4;">
                        <!-- 内容将通过JavaScript动态生成 -->
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 控制说明面板 -->
    <div id="controlsPanel">
        <div class="controls-content">
            <div class="controls-header">
                <h2 data-i18n="controls">游戏控制说明</h2>
                <button class="close-controls" data-i18n="close">关闭</button>
            </div>
            <p data-i18n="controlsDesc" style="color: #a0a0c0; margin-bottom: 20px;">使用键盘控制方块移动和旋转：</p>
            <div class="keyboard-controls-panel">
                <div class="key-item-panel">
                    <div class="key">← →</div>
                    <div class="key-action" data-i18n="moveLeftRight">左右移动</div>
                </div>
                <div class="key-item-panel">
                    <div class="key">↑</div>
                    <div class="key-action" data-i18n="rotatePiece">旋转方块</div>
                </div>
                <div class="key-item-panel">
                    <div class="key">↓</div>
                    <div class="key-action" data-i18n="softDrop">加速下落</div>
                </div>
                <div class="key-item-panel">
                    <div class="key">Space</div>
                    <div class="key-action" data-i18n="hardDrop">硬降落</div>
                </div>
                <div class="key-item-panel">
                    <div class="key">P</div>
                    <div class="key-action" data-i18n="pauseGame">暂停/继续游戏</div>
                </div>
                <div class="key-item-panel">
                    <div class="key">R</div>
                    <div class="key-action" data-i18n="restartGame">重新开始游戏</div>
                </div>
            </div>
            <div style="margin-top: 25px; padding-top: 15px; border-top: 1px solid #2a2a4a;">
                <h3 style="color: #ff9966; margin-bottom: 10px;" data-i18n="gameModes">游戏模式</h3>
                <p id="modesDescriptionText" style="color: #a0a0c0; line-height: 1.5;" data-i18n="modesDescription"></p>
            </div>
        </div>
    </div>
    
    <!-- 排行榜面板 -->
    <div id="leaderboardPanel">
        <div class="leaderboard-content">
            <div class="leaderboard-header">
                <h2 data-i18n="leaderboard">游戏排行榜</h2>
                <button class="close-leaderboard" data-i18n="close">关闭</button>
            </div>
            <div class="leaderboard-tabs">
                <button class="leaderboard-tab active" data-mode="classic" data-i18n="classicMode">经典模式</button>
                <button class="leaderboard-tab" data-mode="challenge" data-i18n="challengeMode">挑战模式</button>
                <button class="leaderboard-tab" data-mode="endless" data-i18n="endlessMode">无尽模式</button>
            </div>
            <div id="classicLeaderboard" class="leaderboard-list">
                <!-- 经典模式排行榜将在这里动态生成 -->
            </div>
            <div id="challengeLeaderboard" class="leaderboard-list" style="display: none;">
                <!-- 挑战模式排行榜将在这里动态生成 -->
            </div>
            <div id="endlessLeaderboard" class="leaderboard-list" style="display: none;">
                <!-- 无尽模式排行榜将在这里动态生成 -->
            </div>
            <button id="clearScoresBtn" class="clear-scores-btn" data-i18n="clearScores">清空当前模式排行榜</button>
        </div>
    </div>
    
    <!-- 更新公告 - 优化版 -->
    <div id="updateNotice">
        <div class="notice-content">
            <!-- 标题板块 -->
            <div class="notice-header-section">
                <div class="notice-header">
                    <h2 data-i18n="updateHistory">俄罗斯方块 - 版本更新历史</h2>
                    <button class="close-notice" data-i18n="close">关闭</button>
                </div>
                <p class="notice-subtitle" data-i18n="updateHistoryDesc">点击左侧版本号查看详细的更新内容和功能特性</p>
            </div>
            
            <!-- 内容板块 -->
            <div class="notice-body-section">
                <!-- 左侧版本号列 -->
                <div class="version-sidebar-container">
                    <div class="sidebar-header">
                        <h3 data-i18n="versionList">版本列表</h3>
                    </div>
                    <div class="version-sidebar" id="versionSidebar">
                        <!-- 版本项将通过JavaScript动态生成 -->
                    </div>
                </div>
                
                <!-- 右侧详情区域 -->
                <div class="version-detail-container">
                    <div class="detail-header">
                        <h3 id="detailTitle" data-i18n="versionDetails">版本详情</h3>
                        <p id="detailSubtitle" data-i18n="selectVersion">选择左侧版本号查看详细信息</p>
                    </div>
                    <div class="version-detail-content" id="versionDetailContent">
                        <!-- 版本详情将通过JavaScript动态生成 -->
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 自定义弹窗 -->
    <div id="customModal" class="custom-modal">
        <div class="custom-modal-content">
            <div class="custom-modal-header">
                <div class="custom-modal-icon" id="modalIcon">📝</div>
                <h3 class="custom-modal-title" id="modalTitle" data-i18n="enterPlayerName">请输入玩家名称</h3>
            </div>
            <div class="custom-modal-body">
                <p class="custom-modal-text" id="modalText" data-i18n="saveScorePrompt">请输入您的名字保存到排行榜：</p>
                <input type="text" id="modalInput" class="custom-modal-input" placeholder="请输入玩家名称" maxlength="20" data-i18n-placeholder="playerNamePlaceholder">
                <p class="custom-modal-text" id="modalScore" style="color: #4dccbd; font-weight: bold; text-align: center;"></p>
            </div>
            <div class="custom-modal-footer">
                <button id="modalCancelBtn" class="custom-modal-btn custom-modal-btn-secondary" data-i18n="cancel">取消</button>
                <button id="modalConfirmBtn" class="custom-modal-btn custom-modal-btn-primary" data-i18n="save">保存</button>
            </div>
        </div>
    </div>
    
    <!-- 保存提示 -->
    <div id="saveNotification" class="save-notification" style="display: none;">
        <span>🎯 <span data-i18n="scoreSaved">当前分数已保存</span></span>
    </div>
    
    <!-- 主菜单界面 -->
    <div id="mainMenu">
        <div class="header">
            <h1 data-i18n="gameTitle">俄罗斯方块</h1>
            <p data-i18n="gameDescription">经典益智游戏的全新体验！选择你喜欢的游戏模式，挑战自己的极限，创造最高分数！</p>
        </div>
        
        <div class="menu-container">
            <div class="menu-card" data-mode="classic">
                <div class="menu-icon">◼◼◼◼</div>
                <h2 data-i18n="classicMode">经典模式</h2>
                <p data-i18n="classicDescription">传统俄罗斯方块玩法，消除行数越多，下落速度越快。挑战你的反应极限！</p>
                <div class="difficulty-badge difficulty-easy" data-i18n="easy">简单</div>
                <button class="menu-btn" data-i18n="startGame">开始游戏</button>
            </div>
            
            <div class="menu-card" id="challengeMenuCard" data-mode="challenge">
                <div class="menu-icon">⚔️</div>
                <h2 data-i18n="challengeMode">挑战模式</h2>
                <p data-i18n="challengeDescription">包含限时模式、隐形模式、40行冲刺和生存模式等多种挑战，测试你的极限能力！</p>
                <div class="difficulty-badge difficulty-expert" data-i18n="expert">专家</div>
                <button class="menu-btn" data-i18n="selectChallenge">选择挑战</button>
            </div>
            
            <div class="menu-card" data-mode="endless">
                <div class="menu-icon">∞</div>
                <h2 data-i18n="endlessMode">无尽模式</h2>
                <p data-i18n="endlessDescription">方块下落速度保持恒定，不会加速。游戏会无限继续，挑战你的耐力极限！</p>
                <div class="difficulty-badge difficulty-medium" data-i18n="medium">中等</div>
                <button class="menu-btn" data-i18n="startGame">开始游戏</button>
            </div>
        </div>
    </div>
    
    <!-- 挑战模式选择界面 -->
    <div id="challengeMenu" style="display: none; max-width: 900px; width: 100%; animation: fadeIn 0.8s ease;">
        <div class="header">
            <h1 data-i18n="challengeMode">挑战模式</h1>
            <p data-i18n="challengeSelectDesc">选择一种挑战模式，测试你的俄罗斯方块极限能力！</p>
        </div>
        
        <div class="menu-container">
            <div class="menu-card" data-challenge="timed">
                <div class="menu-icon">⏱️</div>
                <h2 data-i18n="timedChallenge">限时挑战</h2>
                <p data-i18n="timedDescription">在3分钟内获得尽可能高的分数！时间紧迫，需要快速决策和精准操作。</p>
                <div class="difficulty-badge difficulty-hard" data-i18n="hard">困难</div>
                <button class="menu-btn" data-i18n="startChallenge">开始挑战</button>
            </div>
            
            <div class="menu-card" data-challenge="invisible">
                <div class="menu-icon">👻</div>
                <h2 data-i18n="invisibleMode">隐形模式</h2>
                <p data-i18n="invisibleDescription">底部10行方块完全不可见！依靠记忆和预感来玩俄罗斯方块。注意：不要让方块超过第10行！</p>
                <div class="difficulty-badge difficulty-expert" data-i18n="expert">专家</div>
                <button class="menu-btn" data-i18n="startChallenge">开始挑战</button>
            </div>
            
            <div class="menu-card" data-challenge="invisible2">
                <div class="menu-icon">🔮</div>
                <h2 data-i18n="invisible2Mode">隐形2.0模式</h2>
                <p data-i18n="invisible2Description">方块落地后立即隐形！所有已放置的方块都不可见，真正考验你的记忆力和空间感知！</p>
                <div class="difficulty-badge difficulty-expert" data-i18n="extreme">极限</div>
                <button class="menu-btn" data-i18n="startChallenge">开始挑战</button>
            </div>
            
            <div class="menu-card" data-challenge="sprint">
                <div class="menu-icon">⚡</div>
                <h2 data-i18n="sprint40">40行冲刺</h2>
                <p data-i18n="sprintDescription">以最快速度消除40行方块！时间就是一切，挑战你的最快记录！</p>
                <div class="difficulty-badge difficulty-hard" data-i18n="hard">困难</div>
                <button class="menu-btn" data-i18n="startChallenge">开始挑战</button>
            </div>
            
            <div class="menu-card" data-challenge="survival">
                <div class="menu-icon">💀</div>
                <h2 data-i18n="survivalMode">生存模式</h2>
                <p data-i18n="survivalDescription">每30秒底部会上升一行垃圾行！生存时间越长，难度越大，考验你的持久作战能力！</p>
                <div class="difficulty-badge difficulty-expert" data-i18n="extreme">极限</div>
                <button class="menu-btn" data-i18n="startChallenge">开始挑战</button>
            </div>
            
            <!-- 优化版：马拉松模式卡片 -->
            <div class="menu-card" data-challenge="marathon">
                <div class="menu-icon">🏃</div>
                <h2 data-i18n="marathonMode">马拉松模式</h2>
                <p data-i18n="marathonDescription">持续挑战，不断增长！每75秒目标增加10行，消除行数需要持续累加。每60秒检测目标完成情况，未达成则挑战失败。测试你的持久力！</p>
                <div class="difficulty-badge difficulty-hard" data-i18n="hard">困难</div>
                <button class="menu-btn" data-i18n="startChallenge">开始挑战</button>
            </div>
        </div>
        
        <div style="text-align: center; margin-top: 30px;">
            <button id="backToMainBtn" class="back-btn">← <span data-i18n="backToMenu">返回主菜单</span></button>
        </div>
    </div>
    
    <!-- 游戏界面 -->
    <div id="gameScreen">
        <div class="game-header">
            <button id="backBtn" class="back-btn">← <span data-i18n="back">返回</span></button>
            <h1 class="game-title" id="gameModeTitle" data-i18n="classicTetris">经典俄罗斯方块</h1>
            <div style="width: 100px;"></div>
        </div>
        
        <div class="game-container">
            <div class="game-area">
                <!-- 下一个方块预览区域 -->
                <div class="next-piece-container">
                    <div class="next-piece-title" data-i18n="nextPiece">下一个方块</div>
                    <canvas id="nextCanvas" width="120" height="120"></canvas>
                    <div id="nextPieceName" class="next-piece-name">L型</div>
                </div>
                
                <!-- 游戏主区域 -->
                <div class="game-board">
                    <div id="gameOverlay" class="game-overlay">
                        <div class="start-prompt">
                            <h2 data-i18n="getReady">准备开始</h2>
                            <p data-i18n="pressSpaceToStart">按空格键以开始游戏</p>
                        </div>
                        <div id="countdown" class="countdown" style="display: none;">3</div>
                    </div>
                    
                    <!-- 隐形模式遮罩 -->
                    <div id="invisibleMask" class="invisible-mask" style="display: none;"></div>
                    <div id="invisibleDivider" class="invisible-divider" style="display: none;"></div>
                    
                    <canvas id="gameCanvas" width="300" height="600"></canvas>
                </div>
            </div>
            
            <!-- 游戏信息面板 -->
            <div class="game-info">
                <!-- 冲刺模式进度显示 -->
                <div id="sprintProgressContainer" class="sprint-progress-container" style="display: none;">
                    <div class="sprint-progress-text">
                        <span data-i18n="linesRemaining">剩余行数</span>
                        <span id="sprintLinesLeft">40</span>
                    </div>
                    <div class="challenge-progress">
                        <div id="sprintProgressFill" class="challenge-progress-fill" style="width: 0%;"></div>
                    </div>
                </div>
                
                <!-- 优化版：马拉松模式进度显示 -->
                <div id="marathonProgressContainer" class="marathon-progress-container" style="display: none;">
                    <div class="marathon-progress-text">
                        <span data-i18n="totalLinesTarget">总目标行数</span>
                        <span id="marathonTarget">10</span>
                    </div>
                    <div class="challenge-progress">
                        <div id="marathonProgressFill" class="challenge-progress-fill" style="width: 0%;"></div>
                    </div>
                    <div class="marathon-stage-info">
                        <span id="marathonStageText">已消除: 0/10</span>
                        <span id="marathonNextCheck">下次目标检测: 60秒</span>
                    </div>
                </div>
                
                <div class="info-section">
                    <h2 class="info-title" data-i18n="gameInfo">游戏信息</h2>
                    <div class="info-content">
                        <div class="info-item">
                            <span class="info-label" data-i18n="score">分数</span>
                            <span id="score" class="info-value">0</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label" data-i18n="level">等级</span>
                            <span id="level" class="info-value">1</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label" data-i18n="lines">已消除行数</span>
                            <span id="lines" class="info-value">0</span>
                        </div>
                        <div class="info-item" id="timeElapsedItem" style="display: none;">
                            <span class="info-label" data-i18n="timeElapsed">用时</span>
                            <span id="timeElapsed" class="info-value">00:00</span>
                        </div>
                    </div>
                    
                    <div id="timerContainer" class="timer-container" style="display: none;">
                        <div class="timer-label" data-i18n="timeLeft">剩余时间</div>
                        <div id="timerValue" class="timer-value">03:00</div>
                    </div>
                    
                    <div id="survivalTimerContainer" class="timer-container" style="display: none;">
                        <div class="timer-label" data-i18n="nextGarbageLine">下一波垃圾行</div>
                        <div id="survivalTimerValue" class="timer-value">30秒</div>
                    </div>
                    
                    <!-- 优化版：马拉松模式计时器 -->
                    <div id="marathonTimerContainer" class="timer-container" style="display: none;">
                        <div class="timer-label" data-i18n="nextTargetIncrease">下一个目标增加</div>
                        <div id="marathonTimerValue" class="timer-value">75秒</div>
                    </div>
                </div>
                
                <div class="info-section">
                    <h2 class="info-title" data-i18n="gameStatus">游戏状态</h2>
                    <div id="gameStatus" class="game-status status-ready" data-i18n="waitingToStart">等待开始</div>
                </div>
                
                <div class="controls-section">
                    <button id="pauseBtn" class="control-btn pause-btn">⏸ <span data-i18n="pauseGame">暂停游戏</span> (P)</button>
                    <button id="resetBtn" class="control-btn reset-btn">🔄 <span data-i18n="restartGame">重新开始</span> (R)</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="footer">
        <p>© 2025 俄罗斯方块 - 多模式游戏 | <span data-i18n="version">版本</span> 3.9.1 | <span data-i18n="developedWith">使用HTML5 Canvas和JavaScript开发</span></p>
    </div>

    <script>
        // ============================
        // 背景音乐管理器
        // ============================
        class BGM_Manager {
            constructor() {
                this.audio = null;
                this.currentTrack = null;
                this.isPlaying = false;
                this.volume = 0.5;
                this.basePath = 'audio/bgm/';
                this.tracks = {
                    'menu': 'menu_bgm.mp3',
                    'challenge_menu': 'challenge_menu_bgm.mp3',
                    'game': 'game_bgm.mp3'
                };
                this.enabled = true;
                this.pendingTrack = null;
                this.needsUserInteraction = false;
            }
            
            init() {
                const settings = localStorage.getItem('tetrisSettings');
                if (settings) {
                    try {
                        const parsed = JSON.parse(settings);
                        this.enabled = true;
                        this.volume = (parsed.musicVolume || 70) / 100;
                    } catch (e) {
                        console.warn('加载音乐设置失败，使用默认值:', e);
                    }
                }
                
                this.checkAutoplaySupport();
            }
            
            checkAutoplaySupport() {
                const testAudio = new Audio();
                testAudio.volume = 0;
                const playPromise = testAudio.play();
                
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.log('自动播放被阻止，需要用户交互:', error);
                        this.needsUserInteraction = true;
                    });
                }
            }
            
            play(trackName, force = false) {
                if (!this.enabled) return false;
                
                if (this.currentTrack === trackName && this.isPlaying && !force) {
                    return true;
                }
                
                this.stop();
                
                const fileName = this.tracks[trackName];
                if (!fileName) {
                    console.error(`未找到音轨: ${trackName}`);
                    return false;
                }
                
                this.audio = new Audio(this.basePath + fileName);
                this.audio.volume = this.volume;
                this.audio.loop = true;
                this.currentTrack = trackName;
                
                const playPromise = this.audio.play();
                
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        this.isPlaying = true;
                        console.log(`背景音乐开始播放: ${trackName}`);
                    }).catch(error => {
                        console.log('播放失败，需要用户交互:', error);
                        this.isPlaying = false;
                        this.pendingTrack = trackName;
                        
                        const resumePlay = () => {
                            if (this.pendingTrack && this.audio) {
                                this.audio.play().then(() => {
                                    this.isPlaying = true;
                                    console.log(`背景音乐恢复播放: ${this.pendingTrack}`);
                                }).catch(e => console.log('恢复播放失败:', e));
                            }
                            document.removeEventListener('click', resumePlay);
                            document.removeEventListener('keydown', resumePlay);
                        };
                        
                        document.addEventListener('click', resumePlay, { once: true });
                        document.addEventListener('keydown', resumePlay, { once: true });
                    });
                }
                
                return true;
            }
            
            stop() {
                if (this.audio) {
                    this.audio.pause();
                    this.audio.currentTime = 0;
                    this.isPlaying = false;
                }
                this.currentTrack = null;
            }
            
            pause() {
                if (this.audio && this.isPlaying) {
                    this.audio.pause();
                    this.isPlaying = false;
                }
            }
            
            resume() {
                if (this.audio && !this.isPlaying && this.enabled) {
                    this.audio.play().then(() => {
                        this.isPlaying = true;
                    }).catch(error => {
                        console.log('恢复播放失败:', error);
                    });
                }
            }
            
            setVolume(volume) {
                this.volume = Math.max(0, Math.min(1, volume));
                if (this.audio) {
                    this.audio.volume = this.volume;
                }
            }
            
            setEnabled(enabled) {
                this.enabled = enabled;
                if (!enabled) {
                    this.stop();
                } else if (this.currentTrack) {
                    this.play(this.currentTrack, true);
                }
            }
            
            fadeIn(duration = 1000) {
                if (!this.audio || !this.enabled) return;
                
                const startTime = Date.now();
                const initialVolume = 0;
                const targetVolume = this.volume;
                
                this.audio.volume = initialVolume;
                
                const fade = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(1, elapsed / duration);
                    
                    this.audio.volume = initialVolume + (targetVolume - initialVolume) * progress;
                    
                    if (progress < 1) {
                        requestAnimationFrame(fade);
                    }
                };
                
                fade();
            }
            
            fadeOut(duration = 500) {
                if (!this.audio || !this.isPlaying) return;
                
                const startTime = Date.now();
                const initialVolume = this.audio.volume;
                
                const fade = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(1, elapsed / duration);
                    
                    this.audio.volume = initialVolume * (1 - progress);
                    
                    if (progress < 1) {
                        requestAnimationFrame(fade);
                    } else {
                        this.stop();
                    }
                };
                
                fade();
            }
        }
        
        const bgmManager = new BGM_Manager();
        
        // ============================
        // 特效管理器
        // ============================
        class EffectManager {
            constructor() {
                this.effects = [];
                this.gameBoard = null;
            }
            
            init(gameBoard) {
                this.gameBoard = gameBoard;
            }
            
            createLineClearEffect(lines, x, y, color = '#ff9966') {
                if (!this.gameBoard) return;
                
                const effect = document.createElement('div');
                effect.className = 'line-clear-notification';
                effect.textContent = `${lines} LINES!`;
                effect.style.left = `${x}px`;
                effect.style.top = `${y}px`;
                effect.style.color = color;
                
                this.gameBoard.appendChild(effect);
                
                // 动画
                effect.animate([
                    { transform: 'translate(-50%, -50%) scale(0.5)', opacity: 0 },
                    { transform: 'translate(-50%, -50%) scale(1.2)', opacity: 1 },
                    { transform: 'translate(-50%, -50%) scale(1)', opacity: 1 },
                    { transform: 'translate(-50%, -50%) scale(1.5)', opacity: 0 }
                ], {
                    duration: 1000,
                    easing: 'ease-out'
                });
                
                // 移除元素
                setTimeout(() => {
                    if (effect.parentNode) {
                        effect.parentNode.removeChild(effect);
                    }
                }, 1000);
            }
            
            createScoreAddEffect(score, x, y, color = '#4dccbd') {
                if (!this.gameBoard) return;
                
                const effect = document.createElement('div');
                effect.className = 'score-add-effect';
                effect.textContent = `+${score}`;
                effect.style.left = `${x}px`;
                effect.style.top = `${y}px`;
                effect.style.color = color;
                
                this.gameBoard.appendChild(effect);
                
                // 动画
                effect.animate([
                    { transform: 'translateY(0)', opacity: 1 },
                    { transform: 'translateY(-30px)', opacity: 0 }
                ], {
                    duration: 800,
                    easing: 'ease-out'
                });
                
                // 移除元素
                setTimeout(() => {
                    if (effect.parentNode) {
                        effect.parentNode.removeChild(effect);
                    }
                }, 800);
            }
            
            createClearParticles(x, y, color = '#ff9966') {
                if (!this.gameBoard) return;
                
                const particleCount = 20;
                const container = document.createElement('div');
                container.className = 'clear-effect';
                container.style.left = `${x * 30}px`;
                container.style.top = `${y * 30}px`;
                
                this.gameBoard.appendChild(container);
                
                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'clear-particle';
                    particle.style.backgroundColor = color;
                    particle.style.left = '15px';
                    particle.style.top = '15px';
                    
                    container.appendChild(particle);
                    
                    // 随机方向
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 50 + 30;
                    const tx = Math.cos(angle) * distance;
                    const ty = Math.sin(angle) * distance;
                    
                    particle.animate([
                        { transform: 'translate(0, 0) scale(1)', opacity: 0.9 },
                        { transform: `translate(${tx}px, ${ty}px) scale(0)`, opacity: 0 }
                    ], {
                        duration: 600 + Math.random() * 400,
                        easing: 'ease-out'
                    });
                }
                
                // 移除元素
                setTimeout(() => {
                    if (container.parentNode) {
                        container.parentNode.removeChild(container);
                    }
                }, 1000);
            }
            
            createStageCompleteEffect(stage, x, y) {
                if (!this.gameBoard) return;
                
                const effect = document.createElement('div');
                effect.className = 'line-clear-notification';
                effect.textContent = `阶段 ${stage} 完成!`;
                effect.style.left = `${x}px`;
                effect.style.top = `${y}px`;
                effect.style.color = '#4CAF50';
                effect.style.fontSize = '1.8rem';
                
                this.gameBoard.appendChild(effect);
                
                // 动画
                effect.animate([
                    { transform: 'translate(-50%, -50%) scale(0.5)', opacity: 0 },
                    { transform: 'translate(-50%, -50%) scale(1.2)', opacity: 1 },
                    { transform: 'translate(-50%, -50%) scale(1)', opacity: 1, offset: 0.7 },
                    { transform: 'translate(-50%, -50%) scale(1.5)', opacity: 0 }
                ], {
                    duration: 1500,
                    easing: 'ease-out'
                });
                
                // 移除元素
                setTimeout(() => {
                    if (effect.parentNode) {
                        effect.parentNode.removeChild(effect);
                    }
                }, 1500);
            }
        }
        
        const effectManager = new EffectManager();
        
        // ============================
        // 多语言系统
        // ============================
        
        // 语言包定义
        const LANGUAGE_PACKS = {
            'zh-CN': {
                // 通用
                'gameTitle': '俄罗斯方块',
                'version': '版本',
                'developedWith': '使用HTML5 Canvas和JavaScript开发',
                'close': '关闭',
                'save': '保存',
                'cancel': '取消',
                'back': '返回',
                'backToMenu': '返回主菜单',
                'easy': '简单',
                'medium': '中等',
                'hard': '困难',
                'expert': '专家',
                'extreme': '极限',
                'startGame': '开始游戏',
                'startChallenge': '开始挑战',
                'selectChallenge': '选择挑战',
                'anonymousPlayer': '匿名玩家',
                'failed': '失败',
                'unknownMode': '未知模式',
                'seconds': '秒',
                'heightIndicator': '堆积高度：',
                'rows': '行',
                
                // 设置
                'languageSetting': '界面语言',
                'languageDesc': '选择游戏界面显示的语言',
                'musicVolume': '背景音乐音量',
                'musicVolumeDesc': '调整背景音乐的音量大小',
                'soundVolume': '音效音量',
                'soundVolumeDesc': '调整游戏音效的音量大小',
                
                // 游戏状态
                'gameOver': '游戏结束!',
                'challengeComplete': '挑战完成',
                'saveScore': '保存分数',
                'waitingToStart': '等待开始',
                'playing': '游戏中...',
                'paused': '游戏暂停',
                'timeup': '时间到!',
                'getReady': '准备开始',
                'pressSpaceToStart': '按空格键以开始游戏',
                'pressSpaceToRestart': '按空格键重新开始',
                'challengeEnded': '挑战结束',
                'challengeFailed': '挑战失败',
                'congratulations': '恭喜！',
                'gameEnded': '您的游戏已结束，',
                'enterNameToSave': '请输入名字保存分数到排行榜：',
                'blockExceededLine10': '方块超过了第10行限制',
                'survivalFailed': '生存失败！',
                'marathonFailed': '马拉松挑战失败！',
                'targetNotReached': '未达到目标行数！',
                
                // 游戏信息
                'gameInfo': '游戏信息',
                'score': '分数',
                'level': '等级',
                'lines': '已消除行数',
                'timeElapsed': '用时',
                'timeLeft': '剩余时间',
                'nextGarbageLine': '下一波垃圾行',
                'linesRemaining': '剩余行数',
                'gameStatus': '游戏状态',
                '30seconds': '30秒',
                'totalLinesTarget': '总目标行数',
                'nextTargetIncrease': '下一个目标增加',
                'nextTargetCheck': '下一个目标检测',
                'currentStage': '当前阶段',
                
                // 游戏模式
                'classicMode': '经典模式',
                'challengeMode': '挑战模式',
                'endlessMode': '无尽模式',
                'timedChallenge': '限时挑战',
                'invisibleMode': '隐形模式',
                'invisible2Mode': '隐形2.0模式',
                'sprint40': '40行冲刺',
                'survivalMode': '生存模式',
                'marathonMode': '马拉松模式',
                'classicTetris': '经典俄罗斯方块',
                
                // 模式描述
                'gameDescription': '经典益智游戏的全新体验！选择你喜欢的游戏模式，挑战自己的极限，创造最高分数！',
                'classicDescription': '传统俄罗斯方块玩法，消除行数越多，下落速度越快。挑战你的反应极限！',
                'challengeDescription': '包含限时模式、隐形模式、40行冲刺和生存模式等多种挑战，测试你的极限能力！',
                'endlessDescription': '方块下落速度保持恒定，不会加速。游戏会无限继续，挑战你的耐力极限！',
                'challengeSelectDesc': '选择一种挑战模式，测试你的俄罗斯方块极限能力！',
                'timedDescription': '在3分钟内获得尽可能高的分数！时间紧迫，需要快速决策和精准操作。',
                'invisibleDescription': '底部10行方块完全不可见！依靠记忆和预感来玩俄罗斯方块。注意：不要让方块超过第10行！',
                'invisible2Description': '方块落地后立即隐形！所有已放置的方块都不可见，真正考验你的记忆力和空间感知！',
                'sprintDescription': '以最快速度消除40行方块！时间就是一切，挑战你的最快记录！',
                'survivalDescription': '每30秒底部会上升一行垃圾行！生存时间越长，难度越大，考验你的持久作战能力！',
                'marathonDescription': '持续挑战，不断增长！每75秒目标增加10行，消除行数需要持续累加。每60秒检测目标完成情况，未达成则挑战失败。测试你的持久力！',
                
                // 方块名称
                'piece1': 'I型',
                'piece2': 'J型',
                'piece3': 'L型',
                'piece4': 'O型',
                'piece5': 'S型',
                'piece6': 'T型',
                'piece7': 'Z型',
                'nextPiece': '下一个方块',
                
                // 控制
                'controls': '控制说明',
                'controlsDesc': '使用键盘控制方块移动和旋转：',
                'moveLeftRight': '左右移动',
                'rotatePiece': '旋转方块',
                'softDrop': '加速下落',
                'hardDrop': '硬降落',
                'pauseGame': '暂停游戏',
                'restartGame': '重新开始游戏',
                'resume': '继续',
                'gameModes': '游戏模式',
                'modesDescription': '经典模式：传统俄罗斯方块玩法，消除行数越多，下落速度越快。\n挑战模式：包含多种特殊挑战，测试你的极限能力。\n无尽模式：方块下落速度保持恒定，挑战你的耐力极限！',
                
                // 设置
                'settings': '游戏设置',
                'previewTitle': '方块预览显示',
                'previewDesc': '显示当前方块下落位置的预览',
                'heightlineTitle': '高度指示线',
                'heightlineDesc': '显示当前方块堆积高度的参考线',
                'settingsNoteTitle': '注意：',
                'settingsNoteItem1': '• 在隐形模式下，预览和高度线功能将被自动禁用',
                'settingsNoteItem2': '• 设置会保存到本地，下次游戏时自动加载',
                'settingsNoteItem3': '• 背景音乐和音效可在设置中调整',
                
                // 排行榜
                'leaderboard': '排行榜',
                'clearScores': '清空当前模式排行榜',
                'noScores': '暂无分数记录',
                'scoreSaved': '当前分数已保存',
                'clearSuccess': '已清空当前排行榜',
                'beTheFirst': '成为第一个创造记录的人！',
                
                // 更新公告
                'updates': '更新公告',
                'updateHistory': '俄罗斯方块 - 版本更新历史',
                'updateHistoryDesc': '点击左侧版本号查看详细的更新内容和功能特性',
                'versionList': '版本列表',
                'versionDetails': '版本详情',
                'selectVersion': '选择左侧版本号查看详细信息',
                
                // 弹窗
                'enterPlayerName': '请输入玩家名称',
                'saveScorePrompt': '请输入您的名字保存到排行榜：',
                'playerNamePlaceholder': '请输入玩家名称',
                'currentScore': '当前分数: ',
                'saveScoreConfirm': '确定要保存分数吗？',
                
                // 清除确认
                'clearConfirmTitle': '清空排行榜',
                'clearConfirmText': '确定要清空当前模式的排行榜吗？此操作不可恢复！',
                'delete': '删除',
                
                // 挑战完成消息
                'sprintComplete': '恭喜完成40行冲刺！',
                'survivalComplete': '生存模式挑战结束！',
                'marathonComplete': '马拉松挑战完成！',
                'timeUsed': '用时: ',
                'survivalTime': '生存时间: ',
                'totalStages': '完成阶段: ',
                'totalLines': '总消除行数: '
            },
            
            'zh-TW': {
                // 通用
                'gameTitle': '俄羅斯方塊',
                'version': '版本',
                'developedWith': '使用HTML5 Canvas和JavaScript開發',
                'close': '關閉',
                'save': '保存',
                'cancel': '取消',
                'back': '返回',
                'backToMenu': '返回主選單',
                'easy': '簡單',
                'medium': '中等',
                'hard': '困難',
                'expert': '專家',
                'extreme': '極限',
                'startGame': '開始遊戲',
                'startChallenge': '開始挑戰',
                'selectChallenge': '選擇挑戰',
                'anonymousPlayer': '匿名玩家',
                'failed': '失敗',
                'unknownMode': '未知模式',
                'seconds': '秒',
                'heightIndicator': '堆積高度：',
                'rows': '行',
                
                // 設置
                'languageSetting': '介面語言',
                'languageDesc': '選擇遊戲介面顯示的語言',
                'musicVolume': '背景音樂音量',
                'musicVolumeDesc': '調整背景音樂的音量大小',
                'soundVolume': '音效音量',
                'soundVolumeDesc': '調整遊戲效果音的音量大小',
                'gameOver': '遊戲結束!',
                'challengeComplete': '挑戰完成',
                'saveScore': '保存分數',
                'targetNotReached': '未達到目標行數！',
                
                // 遊戲狀態
                'waitingToStart': '等待開始',
                'playing': '遊戲中...',
                'paused': '遊戲暫停',
                'timeup': '時間到!',
                'getReady': '準備開始',
                'pressSpaceToStart': '按空白鍵以開始遊戲',
                'pressSpaceToRestart': '按空白鍵重新開始',
                'challengeEnded': '挑戰結束',
                'challengeFailed': '挑戰失敗',
                'congratulations': '恭喜！',
                'gameEnded': '您的遊戲已結束，',
                'enterNameToSave': '請輸入名字保存分數到排行榜：',
                'blockExceededLine10': '方塊超過了第10行限制',
                'survivalFailed': '生存失敗！',
                'marathonFailed': '馬拉松挑戰失敗！',
                
                // 遊戲資訊
                'gameInfo': '遊戲資訊',
                'score': '分數',
                'level': '等級',
                'lines': '已消除行數',
                'timeElapsed': '用時',
                'timeLeft': '剩餘時間',
                'nextGarbageLine': '下一波垃圾行',
                'linesRemaining': '剩餘行數',
                'gameStatus': '遊戲狀態',
                '30seconds': '30秒',
                'totalLinesTarget': '總目標行數',
                'nextTargetIncrease': '下一個目標增加',
                'nextTargetCheck': '下一個目標檢測',
                'currentStage': '當前階段',
                
                // 遊戲模式
                'classicMode': '經典模式',
                'challengeMode': '挑戰模式',
                'endlessMode': '無盡模式',
                'timedChallenge': '限時挑戰',
                'invisibleMode': '隱形模式',
                'invisible2Mode': '隱形2.0模式',
                'sprint40': '40行衝刺',
                'survivalMode': '生存模式',
                'marathonMode': '馬拉松模式',
                'classicTetris': '經典俄羅斯方塊',
                
                // 模式描述
                'gameDescription': '經典益智遊戲的全新體驗！選擇你喜歡的遊戲模式，挑戰自己的極限，創造最高分數！',
                'classicDescription': '傳統俄羅斯方塊玩法，消除行數越多，下落速度越快。挑戰你的反應極限！',
                'challengeDescription': '包含限時模式、隱形模式、40行衝刺和生存模式等多種挑戰，測試你的極限能力！',
                'endlessDescription': '方塊下落速度保持恆定，不會加速。遊戲會無限繼續，挑戰你的耐力極限！',
                'challengeSelectDesc': '選擇一種挑戰模式，測試你的俄羅斯方塊極限能力！',
                'timedDescription': '在3分鐘內獲得盡可能高的分數！時間緊迫，需要快速決策和精準操作。',
                'invisibleDescription': '底部10行方塊完全不可見！依靠記憶和預感來玩俄羅斯方塊。注意：不要讓方塊超過第10行！',
                'invisible2Description': '方塊落地後立即隱形！所有已放置的方塊都不可見，真正考驗你的記憶力和空間感知！',
                'sprintDescription': '以最快速度消除40行方塊！時間就是一切，挑戰你的最快記錄！',
                'survivalDescription': '每30秒底部會上升一行垃圾行！生存時間越長，難度越大，考驗你的持久作戰能力！',
                'marathonDescription': '持續挑戰，不斷增長！每75秒目標增加10行，消除行數需要持續累加。每60秒檢測目標完成情況，未達成則挑戰失敗。測試你的持久力！',
                
                // 方塊名稱
                'piece1': 'I型',
                'piece2': 'J型',
                'piece3': 'L型',
                'piece4': 'O型',
                'piece5': 'S型',
                'piece6': 'T型',
                'piece7': 'Z型',
                'nextPiece': '下一個方塊',
                
                // 控制
                'controls': '控制說明',
                'controlsDesc': '使用鍵盤控制方塊移動和旋轉：',
                'moveLeftRight': '左右移動',
                'rotatePiece': '旋轉方塊',
                'softDrop': '加速下落',
                'hardDrop': '硬著陸',
                'pauseGame': '暫停遊戲',
                'restartGame': '重新開始遊戲',
                'resume': '繼續',
                'gameModes': '遊戲模式',
                'modesDescription': '經典模式：傳統俄羅斯方塊玩法，消除行數越多，下落速度越快。\n挑戰模式：包含多種特殊挑戰，測試你的極限能力。\n無盡模式：方塊下落速度保持恆定，挑戰你的耐力極限！',
                
                // 設定
                'settings': '遊戲設定',
                'previewTitle': '方塊預覽顯示',
                'previewDesc': '顯示當前方塊下落位置的預覽',
                'heightlineTitle': '高度指示線',
                'heightlineDesc': '顯示當前方塊堆積高度的參考線',
                'settingsNoteTitle': '注意：',
                'settingsNoteItem1': '• 在隱形模式下，預覽和高度線功能將被自動禁用',
                'settingsNoteItem2': '• 設定會保存到本地，下次遊戲時自動載入',
                'settingsNoteItem3': '• 背景音樂和效果音可在設定中調整',
                
                // 排行榜
                'leaderboard': '排行榜',
                'clearScores': '清空當前模式排行榜',
                'noScores': '暫無分數記錄',
                'scoreSaved': '當前分數已保存',
                'clearSuccess': '已清空當前排行榜',
                'beTheFirst': '成為第一個創造記錄的人！',
                
                // 更新公告
                'updates': '更新公告',
                'updateHistory': '俄羅斯方塊 - 版本更新歷史',
                'updateHistoryDesc': '點擊左側版本號查看詳細的更新內容和功能特性',
                'versionList': '版本列表',
                'versionDetails': '版本詳情',
                'selectVersion': '選擇左側版本號查看詳細信息',
                
                // 彈窗
                'enterPlayerName': '請輸入玩家名稱',
                'saveScorePrompt': '請輸入您的名字保存到排行榜：',
                'playerNamePlaceholder': '請輸入玩家名稱',
                'currentScore': '當前分數: ',
                'saveScoreConfirm': '確定要保存分數嗎？',
                
                // 清除確認
                'clearConfirmTitle': '清空排行榜',
                'clearConfirmText': '確定要清空當前模式的排行榜嗎？此操作不可恢復！',
                'delete': '刪除',
                
                // 挑戰完成消息
                'sprintComplete': '恭喜完成40行衝刺！',
                'survivalComplete': '生存模式挑戰結束！',
                'marathonComplete': '馬拉松挑戰完成！',
                'timeUsed': '用時: ',
                'survivalTime': '生存時間: ',
                'totalStages': '完成階段: ',
                'totalLines': '總消除行數: '
            },
            
            'en-US': {
                // General
                'gameTitle': 'Tetris',
                'version': 'Version',
                'developedWith': 'Developed with HTML5 Canvas and JavaScript',
                'close': 'Close',
                'save': 'Save',
                'cancel': 'Cancel',
                'back': 'Back',
                'backToMenu': 'Back to Menu',
                'easy': 'Easy',
                'medium': 'Medium',
                'hard': 'Hard',
                'expert': 'Expert',
                'extreme': 'Extreme',
                'startGame': 'Start Game',
                'startChallenge': 'Start Challenge',
                'selectChallenge': 'Select Challenge',
                'anonymousPlayer': 'Anonymous Player',
                'failed': 'Failed',
                'unknownMode': 'Unknown Mode',
                'seconds': 'seconds',
                'heightIndicator': 'Stack Height: ',
                'rows': 'rows',
                
                // Settings
                'languageSetting': 'Language',
                'languageDesc': 'Select display language for the game interface',
                'musicVolume': 'Music Volume',
                'musicVolumeDesc': 'Adjust background music volume',
                'soundVolume': 'Sound Volume',
                'soundVolumeDesc': 'Adjust game sound effects volume',
                
                // Game Status
                'gameOver': 'Game Over!',
                'challengeComplete': 'Challenge Complete',
                'saveScore': 'Save Score',
                'waitingToStart': 'Waiting to Start',
                'playing': 'Playing...',
                'paused': 'Game Paused',
                'timeup': 'Time\'s Up!',
                'getReady': 'Get Ready',
                'pressSpaceToStart': 'Press Space to Start Game',
                'pressSpaceToRestart': 'Press Space to Restart',
                'challengeEnded': 'Challenge Ended',
                'challengeFailed': 'Challenge Failed',
                'congratulations': 'Congratulations!',
                'gameEnded': 'Your game has ended, ',
                'enterNameToSave': 'please enter your name to save score to leaderboard:',
                'blockExceededLine10': 'Block exceeded line 10 limit',
                'survivalFailed': 'Survival Failed!',
                'marathonFailed': 'Marathon Challenge Failed!',
                'targetNotReached': 'Target not reached!',
                
                // Game Info
                'gameInfo': 'Game Info',
                'score': 'Score',
                'level': 'Level',
                'lines': 'Lines',
                'timeElapsed': 'Time Elapsed',
                'timeLeft': 'Time Left',
                'nextGarbageLine': 'Next Garbage Line',
                'linesRemaining': 'Lines Remaining',
                'gameStatus': 'Game Status',
                '30seconds': '30 seconds',
                'totalLinesTarget': 'Total Target Lines',
                'nextTargetIncrease': 'Next Target Increase',
                'nextTargetCheck': 'Next Target Check',
                'currentStage': 'Current Stage',
                
                // Game Modes
                'classicMode': 'Classic Mode',
                'challengeMode': 'Challenge Mode',
                'endlessMode': 'Endless Mode',
                'timedChallenge': 'Timed Challenge',
                'invisibleMode': 'Invisible Mode',
                'invisible2Mode': 'Invisible 2.0 Mode',
                'sprint40': '40 Line Sprint',
                'survivalMode': 'Survival Mode',
                'marathonMode': 'Marathon Mode',
                'classicTetris': 'Classic Tetris',
                
                // Mode Descriptions
                'gameDescription': 'A brand new experience of classic puzzle game! Choose your favorite game mode, challenge your limits, and create the highest score!',
                'classicDescription': 'Traditional Tetris gameplay. The more lines you clear, the faster the blocks fall. Challenge your reaction limits!',
                'challengeDescription': 'Includes various special challenges like timed mode, invisible mode, 40-line sprint and survival mode. Test your ultimate abilities!',
                'endlessDescription': 'Block falling speed remains constant without acceleration. The game continues infinitely, challenge your endurance limit!',
                'challengeSelectDesc': 'Choose a challenge mode to test your Tetris ultimate ability!',
                'timedDescription': 'Get as many points as possible in 3 minutes! Time is tight, requiring quick decisions and precise operations.',
                'invisibleDescription': 'The bottom 10 lines are completely invisible! Rely on memory and intuition to play Tetris. Note: Don\'t let blocks exceed line 10!',
                'invisible2Description': 'Blocks become invisible immediately after landing! All placed blocks are invisible, truly testing your memory and spatial awareness!',
                'sprintDescription': 'Clear 40 lines as fast as possible! Time is everything, challenge your fastest record!',
                'survivalDescription': 'A garbage line rises from the bottom every 30 seconds! The longer you survive, the harder it gets, testing your endurance!',
                'marathonDescription': 'Continuous challenge, constantly growing! Target increases by 10 lines every 75 seconds, cleared lines need to accumulate continuously. Every 60 seconds check if target is reached, if not challenge fails. Test your endurance!',
                
                // Piece Names
                'piece1': 'I-Piece',
                'piece2': 'J-Piece',
                'piece3': 'L-Piece',
                'piece4': 'O-Piece',
                'piece5': 'S-Piece',
                'piece6': 'T-Piece',
                'piece7': 'Z-Piece',
                'nextPiece': 'Next Piece',
                
                // Controls
                'controls': 'Controls',
                'controlsDesc': 'Use keyboard to control block movement and rotation:',
                'moveLeftRight': 'Move Left/Right',
                'rotatePiece': 'Rotate Block',
                'softDrop': 'Soft Drop',
                'hardDrop': 'Hard Drop',
                'pauseGame': 'Pause Game',
                'restartGame': 'Restart Game',
                'resume': 'Resume',
                'gameModes': 'Game Modes',
                'modesDescription': 'Classic Mode: Traditional Tetris gameplay. The more lines you clear, the faster the blocks fall.\nChallenge Mode: Includes various special challenges to test your limits.\nEndless Mode: Block falling speed remains constant, challenging your endurance!',
                
                // Settings
                'settings': 'Game Settings',
                'previewTitle': 'Block Preview Display',
                'previewDesc': 'Show preview of current block\'s landing position',
                'heightlineTitle': 'Height Indicator Line',
                'heightlineDesc': 'Show reference line for current block stacking height',
                'settingsNoteTitle': 'Note:',
                'settingsNoteItem1': '• Preview and height line features are automatically disabled in invisible mode',
                'settingsNoteItem2': '• Settings are saved locally and automatically loaded next time',
                'settingsNoteItem3': '• Background music and sound effects can be adjusted in settings',
                
                // Leaderboard
                'leaderboard': 'Leaderboard',
                'clearScores': 'Clear Current Mode Leaderboard',
                'noScores': 'No scores yet',
                'scoreSaved': 'Current score saved',
                'clearSuccess': 'Leaderboard cleared',
                'beTheFirst': 'Be the first to set a record!',
                
                // Updates
                'updates': 'Update History',
                'updateHistory': 'Tetris - Version Update History',
                'updateHistoryDesc': 'Click version numbers on the left to view detailed update content and features',
                'versionList': 'Version List',
                'versionDetails': 'Version Details',
                'selectVersion': 'Select version number on the left to view details',
                
                // Modal
                'enterPlayerName': 'Enter Player Name',
                'saveScorePrompt': 'Please enter your name to save to leaderboard:',
                'playerNamePlaceholder': 'Enter player name',
                'currentScore': 'Current Score: ',
                'saveScoreConfirm': 'Confirm to save score?',
                
                // Clear Confirmation
                'clearConfirmTitle': 'Clear Leaderboard',
                'clearConfirmText': 'Are you sure you want to clear the current mode\'s leaderboard? This action cannot be undone!',
                'delete': 'Delete',
                
                // Challenge Completion Messages
                'sprintComplete': 'Congratulations on completing 40 Line Sprint!',
                'survivalComplete': 'Survival Mode Challenge Ended!',
                'marathonComplete': 'Marathon Challenge Completed!',
                'timeUsed': 'Time: ',
                'survivalTime': 'Survival Time: ',
                'totalStages': 'Stages Completed: ',
                'totalLines': 'Total Lines: '
            },
            
            'ja-JP': {
                // 一般
                'gameTitle': 'テトリス',
                'version': 'バージョン',
                'developedWith': 'HTML5 CanvasとJavaScriptで開発',
                'close': '閉じる',
                'save': '保存',
                'cancel': 'キャンセル',
                'back': '戻る',
                'backToMenu': 'メニューに戻る',
                'easy': '簡単',
                'medium': '普通',
                'hard': '難しい',
                'expert': 'エキスパート',
                'extreme': '極限',
                'startGame': 'ゲーム開始',
                'startChallenge': 'チャレンジ開始',
                'selectChallenge': 'チャレンジ選択',
                'anonymousPlayer': '匿名プレイヤー',
                'failed': '失敗',
                'unknownMode': '不明なモード',
                'seconds': '秒',
                'heightIndicator': '積み上げ高さ：',
                'rows': '行',
                'gameOver': 'ゲームオーバー!',
                'challengeComplete': 'チャレンジ完成',
                'saveScore': 'スコアを保存',
                'targetNotReached': '目標行数に到達しませんでした！',
                
                // 設定
                'languageSetting': '言語設定',
                'languageDesc': 'ゲームの表示言語を選択してください',
                'musicVolume': '音楽音量',
                'musicVolumeDesc': '背景音楽の音量を調整する',
                'soundVolume': '効果音量',
                'soundVolumeDesc': 'ゲーム効果音の音量を調整する',
                
                // ゲーム状態
                'waitingToStart': '開始待機中',
                'playing': 'プレイ中...',
                'paused': 'ゲーム一時停止',
                'timeup': '時間切れ!',
                'getReady': '準備完了',
                'pressSpaceToStart': 'スペースキーでゲーム開始',
                'pressSpaceToRestart': 'スペースキーで再開',
                'challengeEnded': 'チャレンジ終了',
                'challengeFailed': 'チャレンジ失敗',
                'congratulations': 'おめでとうございます！',
                'gameEnded': 'ゲームが終了しました、',
                'enterNameToSave': 'ランキングに保存するために名前を入力してください：',
                'blockExceededLine10': 'ブロックが10行制限を超えました',
                'survivalFailed': 'サバイバル失敗！',
                'marathonFailed': 'マラソンチャレンジ失敗！',
                
                // ゲーム情報
                'gameInfo': 'ゲーム情報',
                'score': 'スコア',
                'level': 'レベル',
                'lines': '消去ライン数',
                'timeElapsed': '経過時間',
                'timeLeft': '残り時間',
                'nextGarbageLine': '次のがらくたライン',
                'linesRemaining': '残りライン数',
                'gameStatus': 'ゲーム状態',
                '30seconds': '30秒',
                'totalLinesTarget': '総目標ライン数',
                'nextTargetIncrease': '次の目標増加',
                'nextTargetCheck': '次の目標チェック',
                'currentStage': '現在のステージ',
                
                // ゲームモード
                'classicMode': 'クラシックモード',
                'challengeMode': 'チャレンジモード',
                'endlessMode': 'エンドレスモード',
                'timedChallenge': 'タイムアタック',
                'invisibleMode': 'インビジブルモード',
                'invisible2Mode': 'インビジブル2.0モード',
                'sprint40': '40ラインスプリント',
                'survivalMode': 'サバイバルモード',
                'marathonMode': 'マラソンモード',
                'classicTetris': 'クラシックテトリス',
                
                // モード説明
                'gameDescription': 'クラシックパズルゲームの新しい体験！お気に入りのゲームモードを選択し、限界に挑戦し、最高スコアを目指しましょう！',
                'classicDescription': '伝統的なテトリスゲームプレイ。消去するラインが多いほど、ブロックの落下速度が速くなります。反応の限界に挑戦しよう！',
                'challengeDescription': 'タイムアタック、インビジブルモード、40ラインスプリント、サバイバルモードなど、様々な特別チャレンジを含みます。あなたの究極の能力をテストしよう！',
                'endlessDescription': 'ブロックの落下速度は一定で加速しません。ゲームは無限に続き、持久力の限界に挑戦しよう！',
                'challengeSelectDesc': 'チャレンジモードを選択して、テトリスの究極の能力をテストしよう！',
                'timedDescription': '3分間でできるだけ高いスコアを獲得しよう！時間が迫っているので、迅速な判断と正確な操作が必要です。',
                'invisibleDescription': '下部10ラインは完全に見えません！記憶と直感に頼ってテトリスをプレイしましょう。注意：ブロックが10ラインを超えないように！',
                'invisible2Description': 'ブロックが着地するとすぐに透明になります！配置されたすべてのブロックは見えません。記憶力と空間認識力を本当にテストします！',
                'sprintDescription': 'できるだけ速く40ラインを消去しよう！時間がすべて、最速記録に挑戦しよう！',
                'survivalDescription': '30秒ごとに底部からがらくたラインが上昇します！生存時間が長いほど難易度が上がり、持久力を試します！',
                'marathonDescription': '継続的な挑戦、絶え間ない成長！75秒ごとに目標が10ライン増加し、消去ラインは継続的に累積する必要があります。60秒ごとに目標達成状況をチェックし、達成されない場合はチャレンジ失敗となります。持久力をテストしよう！',
                
                // ブロック名
                'piece1': 'I型',
                'piece2': 'J型',
                'piece3': 'L型',
                'piece4': 'O型',
                'piece5': 'S型',
                'piece6': 'T型',
                'piece7': 'Z型',
                'nextPiece': '次のブロック',
                
                // 操作
                'controls': '操作説明',
                'controlsDesc': 'キーボードを使用してブロックを移動・回転させます：',
                'moveLeftRight': '左右移動',
                'rotatePiece': 'ブロック回転',
                'softDrop': '加速落下',
                'hardDrop': 'ハードドロップ',
                'pauseGame': 'ゲーム一時停止',
                'restartGame': 'ゲーム再開',
                'resume': '続ける',
                'gameModes': 'ゲームモード',
                'modesDescription': 'クラシックモード：伝統的なテトリスゲームプレイ。消去するラインが多いほど、ブロックの落下速度が速くなります。\nチャレンジモード：様々な特別チャレンジを含み、あなたの限界をテストします。\nエンドレスモード：ブロックの落下速度は一定で、持久力に挑戦します！',
                
                // 設定
                'settings': 'ゲーム設定',
                'previewTitle': 'ブロックプレビュー表示',
                'previewDesc': '現在のブロックの着地位置のプレビューを表示',
                'heightlineTitle': '高さ指示線',
                'heightlineDesc': '現在のブロック積み上げ高さの参考線を表示',
                'settingsNoteTitle': '注意：',
                'settingsNoteItem1': '• インビジブルモードでは、プレビューと高さ線機能は自動的に無効になります',
                'settingsNoteItem2': '• 設定はローカルに保存され、次回ゲーム時に自動的に読み込まれます',
                'settingsNoteItem3': '• 背景音楽と効果音は設定で調整できます',
                
                // ランキング
                'leaderboard': 'ランキング',
                'clearScores': '現在のモードのランキングをクリア',
                'noScores': 'まだスコアがありません',
                'scoreSaved': '現在のスコアを保存しました',
                'clearSuccess': 'ランキングをクリアしました',
                'beTheFirst': '最初に記録を作りましょう！',
                
                // 更新履歴
                'updates': '更新履歴',
                'updateHistory': 'テトリス - バージョン更新履歴',
                'updateHistoryDesc': '左側のバージョン番号をクリックして詳細な更新内容と機能を確認してください',
                'versionList': 'バージョンリスト',
                'versionDetails': 'バージョン詳細',
                'selectVersion': '左側のバージョン番号を選択して詳細を表示',
                
                // モーダル
                'enterPlayerName': 'プレイヤー名を入力',
                'saveScorePrompt': 'ランキングに保存するために名前を入力してください：',
                'playerNamePlaceholder': 'プレイヤー名を入力',
                'currentScore': '現在のスコア: ',
                'saveScoreConfirm': 'スコアを保存しますか？',
                
                // クリア確認
                'clearConfirmTitle': 'ランキングをクリア',
                'clearConfirmText': '現在のモードのランキングをクリアしてもよろしいですか？この操作は元に戻せません！',
                'delete': '削除',
                
                // チャレンジ完了メッセージ
                'sprintComplete': '40ラインスプリント完了おめでとうございます！',
                'survivalComplete': 'サバイバルモードチャレンジ終了！',
                'marathonComplete': 'マラソンチャレンジ完了！',
                'timeUsed': '時間: ',
                'survivalTime': '生存時間: ',
                'totalStages': '完了ステージ: ',
                'totalLines': '総消去ライン数: '
            }
        };
        
        // ============================
        // 语言管理器
        // ============================
        class LanguageManager {
            constructor() {
                this.currentLang = 'zh-CN';
                this.textElements = new Map();
                this.placeholderElements = new Map();
                this.callbacks = [];
            }
            
            init() {
                const savedLang = localStorage.getItem('tetrisLanguage');
                if (savedLang && LANGUAGE_PACKS[savedLang]) {
                    this.currentLang = savedLang;
                } else {
                    this.detectBrowserLanguage();
                }
                
                this.collectTextElements();
                this.updateAllTexts();
                this.updateLanguageButtons();
                this.setupLanguageSwitcher();
            }
            
            collectTextElements() {
                document.querySelectorAll('[data-i18n]').forEach(element => {
                    const key = element.getAttribute('data-i18n');
                    this.textElements.set(element, key);
                });
                
                document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
                    const key = element.getAttribute('data-i18n-placeholder');
                    this.placeholderElements.set(element, key);
                });
            }
            
            updateAllTexts() {
                const langPack = LANGUAGE_PACKS[this.currentLang];
                
                const settingsNoteContainer = document.getElementById('settingsNoteContainer');
                if (settingsNoteContainer && langPack.settingsNoteTitle) {
                    settingsNoteContainer.innerHTML = `
                        <p style="margin-bottom: 5px;"><strong>${langPack.settingsNoteTitle}</strong></p>
                        <p style="margin: 5px 0 0 10px;">${langPack.settingsNoteItem1}</p>
                        <p style="margin: 5px 0 0 10px;">${langPack.settingsNoteItem2}</p>
                        <p style="margin: 5px 0 0 10px;">${langPack.settingsNoteItem3 || ''}</p>
                    `;
                }
                
                const modesDescriptionText = document.getElementById('modesDescriptionText');
                if (modesDescriptionText && langPack.modesDescription) {
                    const text = langPack.modesDescription;
                    modesDescriptionText.innerHTML = text.replace(/\n/g, '<br>');
                }
                
                this.textElements.forEach((key, element) => {
                    if (langPack[key] !== undefined) {
                        if (key === 'modesDescription') return;
                        if (key === 'settingsNote') return;
                        
                        if (element.tagName === 'INPUT' && element.type === 'text') {
                            element.placeholder = langPack[key];
                        } else {
                            element.textContent = langPack[key];
                        }
                    }
                });
                
                this.placeholderElements.forEach((key, element) => {
                    if (langPack[key] !== undefined && element.tagName === 'INPUT') {
                        element.placeholder = langPack[key];
                    }
                });
                
                this.callbacks.forEach(callback => {
                    callback(this.currentLang);
                });
                
                localStorage.setItem('tetrisLanguage', this.currentLang);
            }
            
            updateLanguageButtons() {
                document.querySelectorAll('.lang-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.getAttribute('data-lang') === this.currentLang) {
                        btn.classList.add('active');
                    }
                });
            }
            
            setupLanguageSwitcher() {
                document.querySelectorAll('.lang-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const lang = btn.getAttribute('data-lang');
                        this.changeLanguage(lang);
                    });
                });
            }
            
            changeLanguage(lang) {
                if (!LANGUAGE_PACKS[lang]) {
                    console.error(`Language pack not found: ${lang}`);
                    return false;
                }
                
                this.currentLang = lang;
                this.updateLanguageButtons();
                this.updateAllTexts();
                
                if (window.gameOverlay && window.gameOverlay.style.display === 'flex') {
                    const startPrompt = document.querySelector('.start-prompt');
                    if (startPrompt && startPrompt.innerHTML.includes('<h2>')) {
                        if (gameOver && gameStarted === false) {
                            const currentClass = gameStatusElement.className;
                            if (currentClass.includes('status-gameover')) {
                                let endMessage = '';
                                
                                if (currentMode === GAME_MODES.CHALLENGE && currentChallenge === CHALLENGE_TYPES.TIMED) {
                                    if (gameTime >= timeLimit) {
                                        endMessage = `<h2>${languageManager.getText('timeup')}</h2><p>${languageManager.getText('challengeEnded')}</p><p>${languageManager.getText('pressSpaceToRestart')}</p>`;
                                    } else {
                                        endMessage = `<h2>${languageManager.getText('challengeFailed')}</h2><p>${languageManager.getText('gameOver')}</p><p>${languageManager.getText('pressSpaceToRestart')}</p>`;
                                    }
                                } else if (currentMode === GAME_MODES.CHALLENGE && currentChallenge === CHALLENGE_TYPES.MARATHON) {
                                    if (marathonFailed) {
                                        endMessage = `<h2>${languageManager.getText('marathonFailed')}</h2><p>${languageManager.getText('challengeFailed')}</p><p>${languageManager.getText('pressSpaceToRestart')}</p>`;
                                    } else {
                                        endMessage = `<h2>${languageManager.getText('gameOver')}</h2><p>${languageManager.getText('pressSpaceToRestart')}</p>`;
                                    }
                                } else {
                                    endMessage = `<h2>${languageManager.getText('gameOver')}</h2><p>${languageManager.getText('pressSpaceToRestart')}</p>`;
                                }
                                
                                startPrompt.innerHTML = endMessage;
                            }
                        }
                    }
                }
                
                if (window.updateNextPieceDisplay) {
                    window.updateNextPieceDisplay();
                }
                
                if (window.updateGameStatus) {
                    const currentStatus = window.gameStatusElement ? 
                        window.gameStatusElement.textContent : 'waiting';
                    window.updateGameStatus(getStatusFromText(currentStatus));
                }
                
                // 更新马拉松模式计时器显示
                if (window.updateMarathonTimerDisplay) {
                    window.updateMarathonTimerDisplay();
                }
                
                return true;
            }
            
            detectBrowserLanguage() {
                const browserLang = navigator.language || navigator.userLanguage;
                const supportedLangs = Object.keys(LANGUAGE_PACKS);
                
                if (supportedLangs.includes(browserLang)) {
                    this.currentLang = browserLang;
                    return;
                }
                
                const langPrefix = browserLang.split('-')[0];
                for (const lang of supportedLangs) {
                    if (lang.startsWith(langPrefix)) {
                        this.currentLang = lang;
                        return;
                    }
                }
            }
            
            onLanguageChange(callback) {
                this.callbacks.push(callback);
            }
            
            getText(key) {
                const langPack = LANGUAGE_PACKS[this.currentLang];
                if (langPack && langPack[key] !== undefined) {
                    return langPack[key];
                }
                
                const enPack = LANGUAGE_PACKS['en-US'];
                if (enPack && enPack[key] !== undefined) {
                    console.warn(`Missing translation for "${key}" in ${this.currentLang}, using English fallback`);
                    return enPack[key];
                }
                
                console.warn(`Translation key not found: "${key}"`);
                return key;
            }
        }
        
        function getStatusFromText(statusText) {
            const currentLang = languageManager.currentLang;
            
            // 直接使用当前语言的文本来检测
            if (currentLang === 'zh-CN') {
                if (statusText.includes('等待开始')) return 'waiting';
                if (statusText.includes('游戏中')) return 'playing';
                if (statusText.includes('游戏暂停')) return 'paused';
                if (statusText.includes('游戏结束')) return 'gameover';
                if (statusText.includes('时间到')) return 'timeup';
            } else if (currentLang === 'zh-TW') {
                if (statusText.includes('等待開始')) return 'waiting';
                if (statusText.includes('遊戲中')) return 'playing';
                if (statusText.includes('遊戲暫停')) return 'paused';
                if (statusText.includes('遊戲結束')) return 'gameover';
                if (statusText.includes('時間到')) return 'timeup';
            } else if (currentLang === 'ja-JP') {
                if (statusText.includes('開始待機中')) return 'waiting';
                if (statusText.includes('プレイ中')) return 'playing';
                if (statusText.includes('ゲーム一時停止')) return 'paused';
                if (statusText.includes('ゲームオーバー')) return 'gameover';
                if (statusText.includes('時間切れ')) return 'timeup';
            } else {
                // 英语
                if (statusText.includes('Waiting')) return 'waiting';
                if (statusText.includes('Playing')) return 'playing';
                if (statusText.includes('Game Paused')) return 'paused';
                if (statusText.includes('Game Over')) return 'gameover';
                if (statusText.includes('Time\'s Up')) return 'timeup';
            }
            
            return 'waiting';
        }
        
        const languageManager = new LanguageManager();
        
        // ============================
        // 游戏常量
        // ============================
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        const COLORS = [
            'cyan',     // I型方块
            'blue',     // J型方块
            'orange',   // L型方块
            'yellow',   // O型方块
            'green',    // S型方块
            'purple',   // T型方块
            'red'       // Z型方块
        ];
        
        const SHAPES = [
            // I型
            [
                [0, 0, 0, 0],
                [1, 1, 1, 1],
                [0, 0, 0, 0],
                [0, 0, 0, 0]
            ],
            // J型
            [
                [2, 0, 0],
                [2, 2, 2],
                [0, 0, 0]
            ],
            // L型
            [
                [0, 0, 3],
                [3, 3, 3],
                [0, 0, 0]
            ],
            // O型
            [
                [4, 4],
                [4, 4]
            ],
            // S型
            [
                [0, 5, 5],
                [5, 5, 0],
                [0, 0, 0]
            ],
            // T型
            [
                [0, 6, 0],
                [6, 6, 6],
                [0, 0, 0]
            ],
            // Z型
            [
                [7, 7, 0],
                [0, 7, 7],
                [0, 0, 0]
            ]
        ];
        
        const GAME_MODES = {
            CLASSIC: 'classic',
            CHALLENGE: 'challenge',
            ENDLESS: 'endless'
        };
        
        const CHALLENGE_TYPES = {
            TIMED: 'timed',
            INVISIBLE: 'invisible',
            INVISIBLE2: 'invisible2',
            SPRINT: 'sprint',
            SURVIVAL: 'survival',
            MARATHON: 'marathon'  // 优化版马拉松模式
        };
        
        const VERSION_DATA = [
            {
                version: "3.9.1",
                date: "2025年4月",
                title: "马拉松模式优化",
                description: "取消马拉松模式中达到当前总目标即可完成挑战的机制，同时简化界面显示",
                features: [
                    "取消马拉松模式中达到当前总目标即可完成挑战的机制",
                    "保留60秒检测机制，每60秒检查目标完成情况",
                    "删除游戏信息区中的'下一个目标检测'提示",
                    "简化马拉松模式界面显示，只保留必要信息",
                    "更新马拉松模式描述文本",
                    "优化马拉松模式失败处理逻辑",
                    "修复界面显示问题，提高用户体验"
                ],
                current: true
            },
            {
                version: "3.9.0",
                date: "2025年4月",
                title: "马拉松模式60秒检测机制",
                description: "新增马拉松模式60秒时间检测机制，每60秒检查目标完成情况，未达到目标则挑战失败",
                features: [
                    "新增马拉松模式60秒时间检测机制",
                    "每60秒检测一次目标行数完成情况",
                    "未达到当前阶段目标则挑战失败",
                    "新增马拉松模式检测计时器显示",
                    "更新马拉松模式描述文本，包含60秒检测说明",
                    "添加相关多语言文本支持",
                    "优化马拉松模式失败提示信息"
                ],
                current: false
            },
            {
                version: "3.8.0",
                date: "2025年4月",
                title: "马拉松模式优化",
                description: "优化马拉松模式玩法，目标行数持续累加，更符合传统马拉松玩法",
                features: [
                    "优化马拉松模式：目标行数持续累加，不再重置",
                    "初始目标10行，每75秒目标增加10行",
                    "已消除行数持续累计，达到当前总目标即成功",
                    "增加马拉松模式进度显示，更直观展示进度",
                    "更新多语言文本，添加马拉松模式相关描述",
                    "修复马拉松模式计时器显示问题",
                    "优化马拉松模式完成后的信息展示"
                ],
                current: false
            }
        ];
        
        // ============================
        // 游戏变量
        // ============================
        let canvas, ctx, nextCanvas, nextCtx;
        let board = [];
        let currentPiece, nextPiece;
        let score = 0;
        let level = 1;
        let lines = 0;
        let gameOver = false;
        let isPaused = false;
        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;
        let currentMode = GAME_MODES.CLASSIC;
        let currentChallenge = null;
        let gameTime = 0;
        let timeLimit = 180;
        let gameTimer = null;
        let countdownTimer = null;
        let gameStarted = false;
        let isCountingDown = false;
        let pendingSaveScore = null;
        let invisibleRows = 10;
        let sprintTargetLines = 40;
        let sprintLinesCleared = 0;
        let survivalTimer = 30;
        let survivalGarbageInterval = null;
        let elapsedTime = 0;
        let elapsedTimer = null;
        let cameFromChallengeMenu = false;
        
        // 优化版马拉松模式变量
        let marathonTarget = 10;  // 当前总目标行数（持续累加）
        let marathonLinesCleared = 0;  // 已消除行数（持续累加）
        let marathonIncreaseTimer = 75;  // 目标增加倒计时
        let marathonIncreaseInterval = null;  // 目标增加计时器
        let marathonCheckTimer = 60;  // 目标检测倒计时
        let marathonCheckInterval = null;  // 目标检测计时器
        let marathonStage = 1;  // 当前阶段（每次目标增加算一个阶段）
        let marathonFailed = false;  // 是否因方块堆积到顶而失败
        let marathonCheckFailed = false;  // 是否因未达到目标而失败
        
        // 设置相关
        let showPreview = true;
        let showHeightLine = true;
        let musicVolume = 70;
        let soundVolume = 80;
        
        // 排行榜数据
        let leaderboardData = {
            classic: [],
            challenge: [],
            endless: []
        };
        
        // 音频系统（简化版，只处理音效）
        class AudioSystem {
            constructor() {
                this.audioContext = null;
                this.soundGain = null;
                this.soundBuffers = new Map();
                this.soundVolume = 0.8;
                this.enabled = true;
            }
            
            async init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.soundGain = this.audioContext.createGain();
                    this.soundGain.connect(this.audioContext.destination);
                    
                    this.generateSoundEffects();
                    
                    console.log('音效系统初始化完成');
                } catch (error) {
                    console.warn('音效系统初始化失败，游戏将继续无声运行:', error);
                }
            }
            
            generateSoundEffects() {
                const moveSound = this.createBeepSound(200, 0.1);
                this.soundBuffers.set('move', moveSound);
                
                const rotateSound = this.createBeepSound(300, 0.1);
                this.soundBuffers.set('rotate', rotateSound);
                
                const dropSound = this.createBeepSound(150, 0.15);
                this.soundBuffers.set('drop', dropSound);
                
                const clear1Sound = this.createBeepSound(440, 0.2);
                this.soundBuffers.set('clear1', clear1Sound);
                
                const clear2Sound = this.createChordSound([440, 554.37], 0.25);
                this.soundBuffers.set('clear2', clear2Sound);
                
                const clear3Sound = this.createChordSound([440, 554.37, 659.25], 0.3);
                this.soundBuffers.set('clear3', clear3Sound);
                
                const clear4Sound = this.createChordSound([440, 554.37, 659.25, 830.61], 0.35);
                this.soundBuffers.set('clear4', clear4Sound);
                
                const startSound = this.createChordSound([523.25, 659.25, 783.99], 0.5);
                this.soundBuffers.set('start', startSound);
                
                const gameoverSound = this.createChordSound([392, 349.23, 293.66], 0.6);
                this.soundBuffers.set('gameover', gameoverSound);
                
                const pauseSound = this.createBeepSound(261.63, 0.2);
                this.soundBuffers.set('pause', pauseSound);
                
                const clickSound = this.createBeepSound(400, 0.1);
                this.soundBuffers.set('click', clickSound);
                
                // 马拉松目标增加音效
                const targetIncreaseSound = this.createChordSound([523.25, 659.25, 783.99], 0.6);
                this.soundBuffers.set('targetIncrease', targetIncreaseSound);
                
                // 马拉松目标检测音效
                const targetCheckSound = this.createBeepSound(600, 0.3);
                this.soundBuffers.set('targetCheck', targetCheckSound);
            }
            
            createBeepSound(frequency, duration) {
                if (!this.audioContext) return null;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.value = frequency;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(this.soundVolume * 0.3, this.audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + duration);
                
                return { oscillator, gainNode };
            }
            
            createChordSound(frequencies, duration) {
                if (!this.audioContext) return null;
                
                const gainNode = this.audioContext.createGain();
                gainNode.connect(this.audioContext.destination);
                
                const oscillators = [];
                
                frequencies.forEach((freq, index) => {
                    const oscillator = this.audioContext.createOscillator();
                    oscillator.connect(gainNode);
                    oscillator.frequency.value = freq;
                    oscillator.type = 'sine';
                    oscillators.push(oscillator);
                    
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + duration);
                });
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(this.soundVolume * 0.2, this.audioContext.currentTime + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                
                return { oscillators, gainNode };
            }
            
            playSound(soundName) {
                if (!this.enabled || !this.audioContext || !this.soundBuffers.has(soundName)) {
                    return;
                }
                
                try {
                    const soundData = this.soundBuffers.get(soundName);
                    
                    if (soundData.gainNode) {
                        soundData.gainNode.gain.value = this.soundVolume;
                    }
                    
                    if (soundName.startsWith('clear')) {
                        this.createClearSound(soundName);
                    } else if (soundName === 'targetIncrease') {
                        this.createTargetIncreaseSound();
                    } else if (soundName === 'targetCheck') {
                        this.createTargetCheckSound();
                    } else {
                        this.createBeepSoundForEffect(soundName);
                    }
                } catch (error) {
                    console.warn('播放音效失败:', error);
                }
            }
            
            createClearSound(soundName) {
                if (!this.audioContext) return;
                
                const frequencies = {
                    'clear1': [440],
                    'clear2': [440, 554.37],
                    'clear3': [440, 554.37, 659.25],
                    'clear4': [440, 554.37, 659.25, 830.61]
                };
                
                const freq = frequencies[soundName] || [440];
                const gainNode = this.audioContext.createGain();
                gainNode.connect(this.soundGain);
                
                freq.forEach((f, i) => {
                    const oscillator = this.audioContext.createOscillator();
                    oscillator.connect(gainNode);
                    oscillator.frequency.value = f;
                    oscillator.type = 'triangle';
                    
                    oscillator.start(this.audioContext.currentTime + i * 0.05);
                    oscillator.stop(this.audioContext.currentTime + 0.3 + i * 0.05);
                });
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(this.soundVolume * 0.3, this.audioContext.currentTime + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.5);
            }
            
            createTargetIncreaseSound() {
                if (!this.audioContext) return;
                
                const frequencies = [523.25, 659.25, 783.99];
                const gainNode = this.audioContext.createGain();
                gainNode.connect(this.soundGain);
                
                frequencies.forEach((f, i) => {
                    const oscillator = this.audioContext.createOscillator();
                    oscillator.connect(gainNode);
                    oscillator.frequency.value = f;
                    oscillator.type = 'sine';
                    
                    oscillator.start(this.audioContext.currentTime + i * 0.05);
                    oscillator.stop(this.audioContext.currentTime + 0.6);
                });
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(this.soundVolume * 0.4, this.audioContext.currentTime + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.8);
            }
            
            createTargetCheckSound() {
                if (!this.audioContext) return;
                
                const frequencies = [600, 700, 800];
                const gainNode = this.audioContext.createGain();
                gainNode.connect(this.soundGain);
                
                frequencies.forEach((f, i) => {
                    const oscillator = this.audioContext.createOscillator();
                    oscillator.connect(gainNode);
                    oscillator.frequency.value = f;
                    oscillator.type = 'sine';
                    
                    oscillator.start(this.audioContext.currentTime + i * 0.05);
                    oscillator.stop(this.audioContext.currentTime + 0.5);
                });
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(this.soundVolume * 0.3, this.audioContext.currentTime + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.7);
            }
            
            createBeepSoundForEffect(soundName) {
                if (!this.audioContext) return;
                
                const frequencies = {
                    'move': 200,
                    'rotate': 300,
                    'drop': 150,
                    'start': 523.25,
                    'gameover': 392,
                    'pause': 261.63,
                    'click': 400
                };
                
                const frequency = frequencies[soundName] || 440;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.soundGain);
                
                oscillator.frequency.value = frequency;
                oscillator.type = 'sine';
                
                const duration = soundName === 'start' ? 0.5 : 0.1;
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(this.soundVolume * 0.2, this.audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + duration);
            }
            
            setSoundVolume(volume) {
                this.soundVolume = Math.max(0, Math.min(1, volume / 100));
                if (this.soundGain) {
                    this.soundGain.gain.value = this.soundVolume;
                }
            }
            
            setSoundEnabled(enabled) {
                this.enabled = enabled;
            }
        }
        
        const audioSystem = new AudioSystem();
        
        // ============================
        // DOM元素
        // ============================
        const mainMenu = document.getElementById('mainMenu');
        const challengeMenu = document.getElementById('challengeMenu');
        const gameScreen = document.getElementById('gameScreen');
        const backBtn = document.getElementById('backBtn');
        const backToMainBtn = document.getElementById('backToMainBtn');
        const gameModeTitle = document.getElementById('gameModeTitle');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const linesElement = document.getElementById('lines');
        const nextPieceElement = document.getElementById('nextPieceName');
        const gameStatusElement = document.getElementById('gameStatus');
        const timerContainer = document.getElementById('timerContainer');
        const timerValue = document.getElementById('timerValue');
        const timeElapsedItem = document.getElementById('timeElapsedItem');
        const timeElapsed = document.getElementById('timeElapsed');
        const survivalTimerContainer = document.getElementById('survivalTimerContainer');
        const survivalTimerValue = document.getElementById('survivalTimerValue');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        const challengeMenuCard = document.getElementById('challengeMenuCard');
        
        const invisibleMask = document.getElementById('invisibleMask');
        const invisibleDivider = document.getElementById('invisibleDivider');
        
        const sprintProgressContainer = document.getElementById('sprintProgressContainer');
        const sprintProgressFill = document.getElementById('sprintProgressFill');
        const sprintLinesLeft = document.getElementById('sprintLinesLeft');
        
        // 优化版马拉松模式DOM元素
        const marathonProgressContainer = document.getElementById('marathonProgressContainer');
        const marathonProgressFill = document.getElementById('marathonProgressFill');
        const marathonTargetElement = document.getElementById('marathonTarget');
        const marathonStageText = document.getElementById('marathonStageText');
        const marathonNextCheck = document.getElementById('marathonNextCheck');
        const marathonTimerContainer = document.getElementById('marathonTimerContainer');
        const marathonTimerValue = document.getElementById('marathonTimerValue');
        // 注意：已删除 marathonCheckTimerContainer 和 marathonCheckTimerValue
        
        const topLeftControls = document.getElementById('topLeftControls');
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsPanel = document.getElementById('settingsPanel');
        const closeSettingsBtn = document.querySelector('.close-settings');
        const previewToggle = document.getElementById('previewToggle');
        const heightlineToggle = document.getElementById('heightlineToggle');
        const musicVolumeSlider = document.getElementById('musicVolumeSlider');
        const soundVolumeSlider = document.getElementById('soundVolumeSlider');
        const musicVolumeValue = document.getElementById('musicVolumeValue');
        const soundVolumeValue = document.getElementById('soundVolumeValue');
        
        const controlsBtn = document.getElementById('controlsBtn');
        const leaderboardBtn = document.getElementById('leaderboardBtn');
        const updatesBtn = document.getElementById('updatesBtn');
        
        const controlsPanel = document.getElementById('controlsPanel');
        const leaderboardPanel = document.getElementById('leaderboardPanel');
        const updateNotice = document.getElementById('updateNotice');
        
        const closeControlsBtn = document.querySelector('.close-controls');
        const closeLeaderboardBtn = document.querySelector('.close-leaderboard');
        const closeNoticeBtn = document.querySelector('.close-notice');
        
        const leaderboardTabs = document.querySelectorAll('.leaderboard-tab');
        const classicLeaderboard = document.getElementById('classicLeaderboard');
        const challengeLeaderboard = document.getElementById('challengeLeaderboard');
        const endlessLeaderboard = document.getElementById('endlessLeaderboard');
        const clearScoresBtn = document.getElementById('clearScoresBtn');
        
        const gameOverlay = document.getElementById('gameOverlay');
        const countdownElement = document.getElementById('countdown');
        const startPrompt = document.querySelector('.start-prompt');
        
        const menuCards = document.querySelectorAll('.menu-card');
        const challengeCards = document.querySelectorAll('#challengeMenu .menu-card');
        
        const versionSidebar = document.getElementById('versionSidebar');
        const versionDetailContent = document.getElementById('versionDetailContent');
        const detailTitle = document.getElementById('detailTitle');
        const detailSubtitle = document.getElementById('detailSubtitle');
        
        const customModal = document.getElementById('customModal');
        const modalIcon = document.getElementById('modalIcon');
        const modalTitle = document.getElementById('modalTitle');
        const modalText = document.getElementById('modalText');
        const modalInput = document.getElementById('modalInput');
        const modalScore = document.getElementById('modalScore');
        const modalCancelBtn = document.getElementById('modalCancelBtn');
        const modalConfirmBtn = document.getElementById('modalConfirmBtn');
        
        const saveNotification = document.getElementById('saveNotification');
        
        // ============================
        // 初始化游戏
        // ============================
        async function init() {
            languageManager.init();
            
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            nextCanvas = document.getElementById('nextCanvas');
            nextCtx = nextCanvas.getContext('2d');
            
            createBoard();
            currentPiece = createPiece();
            nextPiece = createPiece();
            updateNextPieceDisplay();
            
            await audioSystem.init();
            bgmManager.init();
            
            // 初始化特效管理器
            effectManager.init(document.querySelector('.game-board'));
            
            loadLeaderboardData();
            loadSettings();
            initVersionList();
            initCustomModal();
            
            document.addEventListener('keydown', handleKeyPress);
            pauseBtn.addEventListener('click', togglePause);
            resetBtn.addEventListener('click', resetGame);
            backBtn.addEventListener('click', handleBackButton);
            backToMainBtn.addEventListener('click', showMainMenu);
            
            settingsBtn.addEventListener('click', () => showPanel(settingsPanel));
            closeSettingsBtn.addEventListener('click', () => hidePanel(settingsPanel));
            
            previewToggle.addEventListener('change', function() {
                showPreview = this.checked;
                saveSettings();
            });
            
            heightlineToggle.addEventListener('change', function() {
                showHeightLine = this.checked;
                saveSettings();
            });
            
            musicVolumeSlider.addEventListener('input', function() {
                musicVolume = this.value;
                musicVolumeValue.textContent = `${musicVolume}%`;
                bgmManager.setVolume(musicVolume / 100);
                saveSettings();
            });
            
            soundVolumeSlider.addEventListener('input', function() {
                soundVolume = this.value;
                soundVolumeValue.textContent = `${soundVolume}%`;
                audioSystem.setSoundVolume(soundVolume);
                saveSettings();
            });
            
            controlsBtn.addEventListener('click', () => {
                showPanel(controlsPanel);
                audioSystem.playSound('click');
            });
            leaderboardBtn.addEventListener('click', () => {
                showPanel(leaderboardPanel);
                updateLeaderboardDisplay();
                audioSystem.playSound('click');
            });
            updatesBtn.addEventListener('click', () => {
                showPanel(updateNotice);
                showVersionDetail(VERSION_DATA[0]);
                audioSystem.playSound('click');
            });
            
            closeControlsBtn.addEventListener('click', () => {
                hidePanel(controlsPanel);
                audioSystem.playSound('click');
            });
            closeLeaderboardBtn.addEventListener('click', () => {
                hidePanel(leaderboardPanel);
                audioSystem.playSound('click');
            });
            closeNoticeBtn.addEventListener('click', () => {
                hidePanel(updateNotice);
                audioSystem.playSound('click');
            });
            
            leaderboardTabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    const mode = this.getAttribute('data-mode');
                    switchLeaderboardTab(mode);
                    audioSystem.playSound('click');
                });
            });
            
            clearScoresBtn.addEventListener('click', showClearLeaderboardConfirm);
            
            [settingsPanel, controlsPanel, leaderboardPanel, updateNotice, customModal].forEach(panel => {
                panel.addEventListener('click', function(e) {
                    if (e.target === panel) {
                        hidePanel(panel);
                        audioSystem.playSound('click');
                    }
                });
            });
            
            menuCards.forEach(card => {
                if (card.id !== 'challengeMenuCard') {
                    card.addEventListener('click', function() {
                        const mode = this.getAttribute('data-mode');
                        if (mode === 'challenge') {
                            showChallengeMenu();
                        } else {
                            cameFromChallengeMenu = false;
                            startGameMode(mode);
                        }
                        audioSystem.playSound('click');
                    });
                }
            });
            
            challengeMenuCard.addEventListener('click', () => {
                showChallengeMenu();
                audioSystem.playSound('click');
            });
            challengeCards.forEach(card => {
                card.addEventListener('click', function() {
                    const challengeType = this.getAttribute('data-challenge');
                    cameFromChallengeMenu = true;
                    startChallengeMode(challengeType);
                    audioSystem.playSound('click');
                });
            });
            
            requestAnimationFrame(gameLoop);
            
            updateUI();
            updateGameStatus('waiting');
            updatePauseButton();
            
            languageManager.onLanguageChange(() => {
                updateNextPieceDisplay();
                updateGameStatusText();
                if (currentChallenge === CHALLENGE_TYPES.MARATHON) {
                    updateMarathonDisplay();
                }
            });
            
            updateSettingsButtonVisibility();
            
            setTimeout(() => {
                bgmManager.play('menu');
            }, 500);
        }
        
        // ============================
        // 游戏核心函数
        // ============================
        function loadSettings() {
            const savedSettings = localStorage.getItem('tetrisSettings');
            if (savedSettings) {
                try {
                    const settings = JSON.parse(savedSettings);
                    showPreview = settings.showPreview !== undefined ? settings.showPreview : true;
                    showHeightLine = settings.showHeightLine !== undefined ? settings.showHeightLine : true;
                    musicVolume = settings.musicVolume !== undefined ? settings.musicVolume : 70;
                    soundVolume = settings.soundVolume !== undefined ? settings.soundVolume : 80;
                    
                    previewToggle.checked = showPreview;
                    heightlineToggle.checked = showHeightLine;
                    musicVolumeSlider.value = musicVolume;
                    soundVolumeSlider.value = soundVolume;
                    musicVolumeValue.textContent = `${musicVolume}%`;
                    soundVolumeValue.textContent = `${soundVolume}%`;
                    
                    audioSystem.setSoundVolume(soundVolume);
                    bgmManager.setVolume(musicVolume / 100);
                } catch (e) {
                    console.error('加载设置失败:', e);
                }
            }
        }
        
        function saveSettings() {
            const settings = {
                showPreview: showPreview,
                showHeightLine: showHeightLine,
                musicVolume: musicVolume,
                soundVolume: soundVolume
            };
            
            try {
                localStorage.setItem('tetrisSettings', JSON.stringify(settings));
                return true;
            } catch (e) {
                console.error('保存设置失败:', e);
                return false;
            }
        }
        
        function updateSettingsButtonVisibility() {
            if (mainMenu.style.display !== 'none') {
                topLeftControls.style.display = 'flex';
            } else {
                topLeftControls.style.display = 'none';
            }
        }
        
        function showChallengeMenu() {
            mainMenu.style.display = 'none';
            challengeMenu.style.display = 'block';
            gameScreen.style.display = 'none';
            cameFromChallengeMenu = false;
            
            bgmManager.fadeOut(300);
            setTimeout(() => {
                bgmManager.play('challenge_menu');
                bgmManager.fadeIn(500);
            }, 350);
            
            updateSettingsButtonVisibility();
        }
        
        function startChallengeMode(challengeType) {
            currentMode = GAME_MODES.CHALLENGE;
            currentChallenge = challengeType;
            
            switch (challengeType) {
                case CHALLENGE_TYPES.TIMED:
                    gameModeTitle.textContent = languageManager.getText('timedChallenge');
                    timerContainer.style.display = 'flex';
                    invisibleMask.style.display = 'none';
                    invisibleDivider.style.display = 'none';
                    sprintProgressContainer.style.display = 'none';
                    marathonProgressContainer.style.display = 'none';
                    survivalTimerContainer.style.display = 'none';
                    marathonTimerContainer.style.display = 'none';
                    timeElapsedItem.style.display = 'none';
                    timeLimit = 180;
                    break;
                    
                case CHALLENGE_TYPES.INVISIBLE:
                    gameModeTitle.textContent = languageManager.getText('invisibleMode');
                    timerContainer.style.display = 'none';
                    invisibleMask.style.display = 'block';
                    invisibleDivider.style.display = 'block';
                    sprintProgressContainer.style.display = 'none';
                    marathonProgressContainer.style.display = 'none';
                    survivalTimerContainer.style.display = 'none';
                    marathonTimerContainer.style.display = 'none';
                    timeElapsedItem.style.display = 'none';
                    timeLimit = 0;
                    showPreview = false;
                    showHeightLine = false;
                    previewToggle.checked = false;
                    heightlineToggle.checked = false;
                    break;
                    
                case CHALLENGE_TYPES.INVISIBLE2:
                    gameModeTitle.textContent = languageManager.getText('invisible2Mode');
                    timerContainer.style.display = 'none';
                    invisibleMask.style.display = 'none';
                    invisibleDivider.style.display = 'none';
                    sprintProgressContainer.style.display = 'none';
                    marathonProgressContainer.style.display = 'none';
                    survivalTimerContainer.style.display = 'none';
                    marathonTimerContainer.style.display = 'none';
                    timeElapsedItem.style.display = 'none';
                    timeLimit = 0;
                    showPreview = false;
                    showHeightLine = false;
                    previewToggle.checked = false;
                    heightlineToggle.checked = false;
                    break;
                    
                case CHALLENGE_TYPES.SPRINT:
                    gameModeTitle.textContent = languageManager.getText('sprint40');
                    timerContainer.style.display = 'none';
                    invisibleMask.style.display = 'none';
                    invisibleDivider.style.display = 'none';
                    sprintProgressContainer.style.display = 'block';
                    marathonProgressContainer.style.display = 'none';
                    survivalTimerContainer.style.display = 'none';
                    marathonTimerContainer.style.display = 'none';
                    timeElapsedItem.style.display = 'flex';
                    timeLimit = 0;
                    break;
                    
                case CHALLENGE_TYPES.SURVIVAL:
                    gameModeTitle.textContent = languageManager.getText('survivalMode');
                    timerContainer.style.display = 'none';
                    invisibleMask.style.display = 'none';
                    invisibleDivider.style.display = 'none';
                    sprintProgressContainer.style.display = 'none';
                    marathonProgressContainer.style.display = 'none';
                    survivalTimerContainer.style.display = 'flex';
                    marathonTimerContainer.style.display = 'none';
                    timeElapsedItem.style.display = 'flex';
                    timeLimit = 0;
                    break;
                    
                case CHALLENGE_TYPES.MARATHON:
                    gameModeTitle.textContent = languageManager.getText('marathonMode');
                    timerContainer.style.display = 'none';
                    invisibleMask.style.display = 'none';
                    invisibleDivider.style.display = 'none';
                    sprintProgressContainer.style.display = 'none';
                    marathonProgressContainer.style.display = 'block';
                    survivalTimerContainer.style.display = 'none';
                    marathonTimerContainer.style.display = 'flex';
                    timeElapsedItem.style.display = 'flex';
                    timeLimit = 0;
                    
                    // 初始化优化版马拉松模式变量
                    marathonTarget = 10;  // 初始目标10行
                    marathonLinesCleared = 0;  // 已消除行数从0开始
                    marathonIncreaseTimer = 75;  // 目标增加倒计时75秒
                    marathonCheckTimer = 60;  // 目标检测倒计时60秒
                    marathonStage = 1;  // 当前阶段为1
                    marathonFailed = false;  // 未失败
                    marathonCheckFailed = false;  // 未因检测失败
                    
                    // 更新显示
                    updateMarathonDisplay();
                    break;
            }
            
            challengeMenu.style.display = 'none';
            gameScreen.style.display = 'block';
            
            bgmManager.fadeOut(300);
            setTimeout(() => {
                bgmManager.play('game');
                bgmManager.fadeIn(500);
            }, 350);
            
            resetGame();
            updateSettingsButtonVisibility();
        }
        
        function startGameMode(mode) {
            currentMode = mode;
            currentChallenge = null;
            
            loadSettings();
            
            switch (mode) {
                case 'classic':
                    gameModeTitle.textContent = languageManager.getText('classicTetris');
                    timerContainer.style.display = 'none';
                    invisibleMask.style.display = 'none';
                    invisibleDivider.style.display = 'none';
                    sprintProgressContainer.style.display = 'none';
                    marathonProgressContainer.style.display = 'none';
                    survivalTimerContainer.style.display = 'none';
                    marathonTimerContainer.style.display = 'none';
                    timeElapsedItem.style.display = 'none';
                    break;
                case 'endless':
                    gameModeTitle.textContent = languageManager.getText('endlessMode');
                    timerContainer.style.display = 'none';
                    invisibleMask.style.display = 'none';
                    invisibleDivider.style.display = 'none';
                    sprintProgressContainer.style.display = 'none';
                    marathonProgressContainer.style.display = 'none';
                    survivalTimerContainer.style.display = 'none';
                    marathonTimerContainer.style.display = 'none';
                    timeElapsedItem.style.display = 'none';
                    break;
            }
            
            mainMenu.style.display = 'none';
            challengeMenu.style.display = 'none';
            gameScreen.style.display = 'block';
            
            bgmManager.fadeOut(300);
            setTimeout(() => {
                bgmManager.play('game');
                bgmManager.fadeIn(500);
            }, 350);
            
            resetGame();
            updateSettingsButtonVisibility();
        }
        
        function createBoard() {
            board = [];
            for (let y = 0; y < ROWS; y++) {
                board[y] = [];
                for (let x = 0; x < COLS; x++) {
                    board[y][x] = 0;
                }
            }
        }
        
        function createPiece() {
            const pieceId = Math.floor(Math.random() * SHAPES.length);
            const shape = SHAPES[pieceId];
            
            const piece = {
                shape: shape,
                color: COLORS[pieceId],
                id: pieceId + 1,
                x: Math.floor(COLS / 2) - Math.floor(shape[0].length / 2),
                y: 0
            };
            
            return piece;
        }
        
        function drawBoard() {
            ctx.fillStyle = '#0f1123';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 0.5;
            
            for (let x = 0; x <= COLS; x++) {
                ctx.beginPath();
                const endY = currentChallenge === CHALLENGE_TYPES.INVISIBLE ? 
                    (ROWS - invisibleRows) * BLOCK_SIZE : canvas.height;
                ctx.moveTo(x * BLOCK_SIZE, 0);
                ctx.lineTo(x * BLOCK_SIZE, endY);
                ctx.stroke();
            }
            
            for (let y = 0; y <= ROWS; y++) {
                if (currentChallenge === CHALLENGE_TYPES.INVISIBLE && y > ROWS - invisibleRows) {
                    continue;
                }
                
                ctx.beginPath();
                ctx.moveTo(0, y * BLOCK_SIZE);
                ctx.lineTo(canvas.width, y * BLOCK_SIZE);
                ctx.stroke();
            }
            
            for (let y = 0; y < ROWS; y++) {
                if (currentChallenge === CHALLENGE_TYPES.INVISIBLE && y > ROWS - invisibleRows) {
                    continue;
                }
                if (currentChallenge === CHALLENGE_TYPES.INVISIBLE2) {
                    continue;
                }
                
                for (let x = 0; x < COLS; x++) {
                    if (board[y][x]) {
                        drawBlock(ctx, x, y, COLORS[board[y][x] - 1]);
                    }
                }
            }
            
            if (showPreview && currentPiece && gameStarted && !isPaused && !gameOver) {
                if (!(currentChallenge === CHALLENGE_TYPES.INVISIBLE || currentChallenge === CHALLENGE_TYPES.INVISIBLE2)) {
                    const preview = { ...currentPiece };
                    while (!collision(preview, board, 0, 1)) {
                        preview.y++;
                    }
                    
                    for (let y = 0; y < preview.shape.length; y++) {
                        for (let x = 0; x < preview.shape[y].length; x++) {
                            if (preview.shape[y][x]) {
                                const boardY = preview.y + y;
                                if (!(currentChallenge === CHALLENGE_TYPES.INVISIBLE && boardY > ROWS - invisibleRows)) {
                                    drawPreviewBlock(ctx, preview.x + x, boardY, preview.color);
                                }
                            }
                        }
                    }
                }
            }
            
            if (showHeightLine && gameStarted && !isPaused && !gameOver) {
                if (!(currentChallenge === CHALLENGE_TYPES.INVISIBLE || currentChallenge === CHALLENGE_TYPES.INVISIBLE2)) {
                    let topRowWithBlock = -1;
                    
                    for (let y = 0; y < ROWS; y++) {
                        for (let x = 0; x < COLS; x++) {
                            if (board[y][x]) {
                                topRowWithBlock = y;
                                break;
                            }
                        }
                        if (topRowWithBlock !== -1) break;
                    }
                    
                    if (topRowWithBlock !== -1) {
                        const currentStackHeight = ROWS - topRowWithBlock;
                        if (currentStackHeight >= 2) {
                            drawHeightIndicatorLine(topRowWithBlock, currentStackHeight);
                        }
                    }
                }
            }
            
            if (currentChallenge === CHALLENGE_TYPES.INVISIBLE) {
                for (let y = 0; y < currentPiece.shape.length; y++) {
                    for (let x = 0; x < currentPiece.shape[y].length; x++) {
                        if (currentPiece.shape[y][x]) {
                            const boardY = currentPiece.y + y;
                            if (boardY <= ROWS - invisibleRows) {
                                drawBlock(ctx, currentPiece.x + x, boardY, currentPiece.color);
                            }
                        }
                    }
                }
            } else if (currentChallenge === CHALLENGE_TYPES.INVISIBLE2) {
                drawPiece(currentPiece);
            } else {
                drawPiece(currentPiece);
            }
            
            if (currentChallenge === CHALLENGE_TYPES.INVISIBLE) {
                const splitLineY = (ROWS - invisibleRows) * BLOCK_SIZE;
                
                invisibleDivider.style.top = `${splitLineY}px`;
                
                ctx.save();
                ctx.strokeStyle = '#9C27B0';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(0, splitLineY);
                ctx.lineTo(canvas.width, splitLineY);
                ctx.stroke();
                ctx.restore();
            }
        }
        
        function drawPreviewBlock(context, x, y, color) {
            context.fillStyle = color.replace(')', ', 0.3)').replace('rgb', 'rgba');
            context.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            
            context.strokeStyle = color;
            context.lineWidth = 1;
            context.setLineDash([3, 3]);
            context.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            context.setLineDash([]);
            
            context.fillStyle = 'rgba(255, 255, 255, 0.1)';
            context.fillRect(x * BLOCK_SIZE + 2, y * BLOCK_SIZE + 2, BLOCK_SIZE - 4, 8);
            context.fillRect(x * BLOCK_SIZE + 2, y * BLOCK_SIZE + 2, 8, BLOCK_SIZE - 4);
        }
        
        function drawHeightIndicatorLine(lineY, stackHeight) {
            ctx.save();
            ctx.strokeStyle = '#2196F3';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(0, lineY * BLOCK_SIZE);
            ctx.lineTo(canvas.width, lineY * BLOCK_SIZE);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.restore();
            
            ctx.save();
            ctx.fillStyle = '#2196F3';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            
            const text = `${languageManager.getText('heightIndicator')} ${stackHeight} ${languageManager.getText('rows')}`;
            ctx.fillText(text, 5, lineY * BLOCK_SIZE + 15);
            ctx.restore();
        }
        
        function drawPiece(piece) {
            for (let y = 0; y < piece.shape.length; y++) {
                for (let x = 0; x < piece.shape[y].length; x++) {
                    if (piece.shape[y][x]) {
                        drawBlock(ctx, piece.x + x, piece.y + y, piece.color);
                    }
                }
            }
        }
        
        function drawBlock(context, x, y, color) {
            context.fillStyle = color;
            context.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            
            context.strokeStyle = '#fff';
            context.lineWidth = 1;
            context.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            
            context.fillStyle = 'rgba(255, 255, 255, 0.2)';
            context.fillRect(x * BLOCK_SIZE + 2, y * BLOCK_SIZE + 2, BLOCK_SIZE - 4, 8);
            context.fillRect(x * BLOCK_SIZE + 2, y * BLOCK_SIZE + 2, 8, BLOCK_SIZE - 4);
            
            context.fillStyle = 'rgba(0, 0, 0, 0.2)';
            context.fillRect(x * BLOCK_SIZE + 8, y * BLOCK_SIZE + BLOCK_SIZE - 4, BLOCK_SIZE - 8, 4);
            context.fillRect(x * BLOCK_SIZE + BLOCK_SIZE - 4, y * BLOCK_SIZE + 8, 4, BLOCK_SIZE - 8);
        }
        
        function drawNextPiece() {
            nextCtx.fillStyle = '#0f1123';
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            
            if (!nextPiece) return;
            
            const offsetX = (nextCanvas.width / BLOCK_SIZE - nextPiece.shape[0].length) / 2;
            const offsetY = (nextCanvas.height / BLOCK_SIZE - nextPiece.shape.length) / 2;
            
            for (let y = 0; y < nextPiece.shape.length; y++) {
                for (let x = 0; x < nextPiece.shape[y].length; x++) {
                    if (nextPiece.shape[y][x]) {
                        drawBlock(nextCtx, offsetX + x, offsetY + y, nextPiece.color);
                    }
                }
            }
        }
        
        function collision(piece, board, dx = 0, dy = 0) {
            for (let y = 0; y < piece.shape.length; y++) {
                for (let x = 0; x < piece.shape[y].length; x++) {
                    if (piece.shape[y][x]) {
                        const newX = piece.x + x + dx;
                        const newY = piece.y + y + dy;
                        
                        if (
                            newX < 0 || 
                            newX >= COLS || 
                            newY >= ROWS || 
                            (newY >= 0 && board[newY] && board[newY][newX])
                        ) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        function rotatePiece(piece) {
            const rotated = [];
            for (let i = 0; i < piece.shape[0].length; i++) {
                rotated[i] = [];
                for (let j = piece.shape.length - 1; j >= 0; j--) {
                    rotated[i][piece.shape.length - 1 - j] = piece.shape[j][i];
                }
            }
            
            const originalShape = piece.shape;
            piece.shape = rotated;
            
            if (collision(piece, board)) {
                piece.shape = originalShape;
                return false;
            }
            
            return true;
        }
        
        function movePiece(dx, dy) {
            if (!collision(currentPiece, board, dx, dy)) {
                currentPiece.x += dx;
                currentPiece.y += dy;
                
                if (dx !== 0) {
                    audioSystem.playSound('move');
                } else if (dy > 0) {
                    audioSystem.playSound('drop');
                }
                
                return true;
            }
            
            if (dy > 0) {
                lockPiece();
            }
            
            return false;
        }
        
        function lockPiece() {
            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        const boardY = currentPiece.y + y;
                        if (boardY >= 0) {
                            board[boardY][currentPiece.x + x] = currentPiece.id;
                            
                            if (currentChallenge === CHALLENGE_TYPES.INVISIBLE && 
                                boardY < ROWS - invisibleRows) {
                                invisibleModeFail();
                                return;
                            }
                        }
                    }
                }
            }
            
            if (currentPiece.y <= 0) {
                endGame();
                return;
            }
            
            clearLines();
            
            currentPiece = nextPiece;
            nextPiece = createPiece();
            updateNextPieceDisplay();
            
            if (collision(currentPiece, board)) {
                endGame();
            }
        }
        
        function invisibleModeFail() {
            gameOver = true;
            gameStarted = false;
            stopTimer();
            stopMarathonTimer();
            
            gameOverlay.style.display = 'flex';
            startPrompt.style.display = 'block';
            
            let endMessage = `<h2>${languageManager.getText('invisibleMode')} ${languageManager.getText('failed')}</h2><p>${languageManager.getText('blockExceededLine10')}</p><p>${languageManager.getText('pressSpaceToRestart')}</p>`;
            startPrompt.innerHTML = endMessage;
            
            updateGameStatus('gameover');
            
            audioSystem.playSound('gameover');
            
            if (score > 0) {
                setTimeout(() => {
                    pendingSaveScore = score;
                    showCustomModal(
                        languageManager.getText('invisibleMode') + ' ' + languageManager.getText('challengeFailed'),
                        `${languageManager.getText('invisibleMode')} ${languageManager.getText('challengeFailed')} ${languageManager.getText('enterNameToSave')}`,
                        score,
                        '👻'
                    );
                }, 500);
            }
            
            updatePauseButton();
        }
        
        function clearLines() {
            let linesCleared = 0;
            let clearedRows = [];
            
            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== 0)) {
                    clearedRows.push(y);
                    board.splice(y, 1);
                    board.unshift(Array(COLS).fill(0));
                    linesCleared++;
                    y++;
                    
                    // 创建清除特效
                    effectManager.createClearParticles(5, y, '#ff9966');
                }
            }
            
            if (linesCleared > 0) {
                const soundName = `clear${linesCleared}`;
                audioSystem.playSound(soundName);
                
                // 创建行数消除特效（所有语言都用英语显示）
                const canvasX = canvas.offsetLeft + canvas.width / 2;
                const canvasY = canvas.offsetTop + canvas.height / 2;
                effectManager.createLineClearEffect(linesCleared, canvasX, canvasY);
                
                if (currentChallenge === CHALLENGE_TYPES.SPRINT) {
                    sprintLinesCleared += linesCleared;
                    const progress = Math.min(100, Math.floor((sprintLinesCleared / sprintTargetLines) * 100));
                    sprintProgressFill.style.width = `${progress}%`;
                    sprintLinesLeft.textContent = `${sprintTargetLines - sprintLinesCleared}`;
                    
                    if (sprintLinesCleared >= sprintTargetLines) {
                        sprintComplete();
                        return;
                    }
                }
                
                // 优化版马拉松模式进度更新
                if (currentChallenge === CHALLENGE_TYPES.MARATHON) {
                    marathonLinesCleared += linesCleared;
                    
                    // 注意：取消达到当前总目标即可完成挑战的机制
                    // 不再检查是否达到当前总目标
                    
                    const progress = Math.min(100, Math.floor((marathonLinesCleared / marathonTarget) * 100));
                    marathonProgressFill.style.width = `${progress}%`;
                }
                
                const oldScore = score;
                updateScore(linesCleared);
                const scoreAdded = score - oldScore;
                
                // 创建分数增加特效
                if (scoreAdded > 0) {
                    const scoreX = canvas.offsetLeft + canvas.width - 100;
                    const scoreY = canvas.offsetTop + 100;
                    effectManager.createScoreAddEffect(scoreAdded, scoreX, scoreY);
                }
                
                if (currentMode === GAME_MODES.CLASSIC) {
                    lines += linesCleared;
                    level = Math.floor(lines / 10) + 1;
                    dropInterval = Math.max(100, 1000 - (level - 1) * 100);
                } else if (currentMode === GAME_MODES.ENDLESS) {
                    lines += linesCleared;
                    level = Math.floor(lines / 10) + 1;
                } else if (currentMode === GAME_MODES.CHALLENGE) {
                    lines += linesCleared;
                    level = Math.floor(lines / 10) + 1;
                    
                    if (currentChallenge === CHALLENGE_TYPES.TIMED) {
                        dropInterval = Math.max(300, 800 - (level - 1) * 50);
                    } else if (currentChallenge === CHALLENGE_TYPES.SPRINT) {
                        level = Math.floor(lines / 5) + 1;
                        dropInterval = Math.max(200, 800 - (level - 1) * 60);
                    } else if (currentChallenge === CHALLENGE_TYPES.MARATHON) {
                        level = Math.floor(lines / 10) + 1;
                        dropInterval = Math.max(300, 800 - (level - 1) * 30);
                    } else {
                        dropInterval = Math.max(300, 800 - (level - 1) * 30);
                    }
                }
                
                updateUI();
            }
        }
        
        function sprintComplete() {
            gameOver = true;
            gameStarted = false;
            stopTimer();
            stopElapsedTimer();
            
            gameOverlay.style.display = 'flex';
            startPrompt.style.display = 'block';
            
            const minutes = Math.floor(elapsedTime / 60);
            const seconds = Math.floor(elapsedTime % 60);
            const timeText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            let endMessage = `<h2>${languageManager.getText('congratulations')}</h2><p>${languageManager.getText('timeUsed')} ${timeText}</p><p>${languageManager.getText('pressSpaceToRestart')}</p>`;
            startPrompt.innerHTML = endMessage;
            
            updateGameStatus('gameover');
            
            audioSystem.playSound('gameover');
            
            setTimeout(() => {
                pendingSaveScore = score;
                showCustomModal(
                    languageManager.getText('challengeComplete'),
                    `${languageManager.getText('sprintComplete')} ${languageManager.getText('timeUsed')} ${timeText}\n${languageManager.getText('enterNameToSave')}`,
                    score,
                    '⚡'
                );
            }, 500);
            
            updatePauseButton();
        }
        
        function addGarbageLine() {
            board.shift();
            
            const garbageLine = [];
            const holePos = Math.floor(Math.random() * COLS);
            for (let x = 0; x < COLS; x++) {
                garbageLine[x] = (x === holePos) ? 0 : 8;
            }
            board.push(garbageLine);
            
            for (let x = 0; x < COLS; x++) {
                if (board[0][x] !== 0) {
                    survivalFail();
                    return;
                }
            }
        }
        
        function survivalFail() {
            gameOver = true;
            gameStarted = false;
            stopTimer();
            stopElapsedTimer();
            stopSurvivalTimer();
            
            gameOverlay.style.display = 'flex';
            startPrompt.style.display = 'block';
            
            const minutes = Math.floor(elapsedTime / 60);
            const seconds = Math.floor(elapsedTime % 60);
            const timeText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            let endMessage = `<h2>${languageManager.getText('survivalFailed')}</h2><p>${languageManager.getText('survivalTime')} ${timeText}</p><p>${languageManager.getText('pressSpaceToRestart')}</p>`;
            startPrompt.innerHTML = endMessage;
            
            updateGameStatus('gameover');
            
            audioSystem.playSound('gameover');
            
            setTimeout(() => {
                pendingSaveScore = score;
                showCustomModal(
                    languageManager.getText('gameOver'),
                    `${languageManager.getText('survivalComplete')} ${languageManager.getText('survivalTime')} ${timeText}\n${languageManager.getText('enterNameToSave')}`,
                    score,
                    '💀'
                );
            }, 500);
            
            updatePauseButton();
        }
        
        function updateScore(linesCleared) {
            const linePoints = [0, 40, 100, 300, 1200];
            let baseScore = linePoints[linesCleared] * level;
            
            if (currentMode === GAME_MODES.CHALLENGE) {
                if (currentChallenge === CHALLENGE_TYPES.INVISIBLE || currentChallenge === CHALLENGE_TYPES.INVISIBLE2) {
                    baseScore *= 2.0;
                }
                
                if (currentChallenge === CHALLENGE_TYPES.TIMED) {
                    const timeBonus = Math.floor(gameTime) * 3;
                    score += baseScore + timeBonus;
                } else if (currentChallenge === CHALLENGE_TYPES.SPRINT) {
                    const timeBonus = Math.max(0, 300 - elapsedTime) * 10;
                    score += baseScore + timeBonus;
                } else if (currentChallenge === CHALLENGE_TYPES.SURVIVAL) {
                    const timeBonus = Math.floor(elapsedTime) * 5;
                    score += baseScore + timeBonus;
                } else if (currentChallenge === CHALLENGE_TYPES.MARATHON) {
                    // 马拉松模式：每阶段额外奖励，阶段越高奖励越多
                    const stageBonus = marathonStage * 100;
                    const timeBonus = Math.floor(elapsedTime) * 2;
                    score += baseScore + stageBonus + timeBonus;
                } else {
                    score += baseScore;
                }
            } else {
                score += baseScore;
            }
        }
        
        function hardDrop() {
            if (gameStarted && !isPaused && !gameOver) {
                while (movePiece(0, 1)) {
                }
            }
        }
        
        function startCountdown() {
            if (isCountingDown) return;
            
            isCountingDown = true;
            gameStarted = false;
            isPaused = false;
            gameOver = false;
            
            startPrompt.style.display = 'none';
            countdownElement.style.display = 'block';
            
            let count = 3;
            countdownElement.textContent = count;
            
            countdownTimer = setInterval(() => {
                count--;
                countdownElement.textContent = count;
                
                countdownElement.style.animation = 'none';
                setTimeout(() => {
                    countdownElement.style.animation = 'countdownPulse 0.5s ease';
                }, 10);
                
                if (count <= 0) {
                    stopCountdown();
                    startGameplay();
                }
            }, 1000);
        }
        
        function stopCountdown() {
            if (countdownTimer) {
                clearInterval(countdownTimer);
                countdownTimer = null;
            }
            isCountingDown = false;
            countdownElement.style.display = 'none';
            startPrompt.style.display = 'block';
        }
        
        function startGameplay() {
            gameStarted = true;
            isPaused = false;
            gameOver = false;
            
            elapsedTime = 0;
            gameTime = 0;
            sprintLinesCleared = 0;
            survivalTimer = 30;
            
            // 优化版马拉松模式初始化
            marathonLinesCleared = 0;
            marathonIncreaseTimer = 75;
            marathonCheckTimer = 60;  // 目标检测计时器
            marathonStage = 1;
            marathonFailed = false;
            marathonCheckFailed = false;
            
            survivalTimerValue.textContent = `30 ${languageManager.getText('seconds')}`;
            sprintLinesLeft.textContent = "40";
            sprintProgressFill.style.width = "0%";
            
            // 更新马拉松显示
            updateMarathonDisplay();
            
            gameOverlay.style.display = 'none';
            
            audioSystem.playSound('start');
            
            if (bgmManager.enabled && !bgmManager.isPlaying) {
                bgmManager.play('game');
            }
            
            if (currentMode === GAME_MODES.CLASSIC) {
                dropInterval = 1000;
            } else if (currentMode === GAME_MODES.ENDLESS) {
                dropInterval = 800;
            } else if (currentMode === GAME_MODES.CHALLENGE) {
                if (currentChallenge === CHALLENGE_TYPES.TIMED) {
                    dropInterval = 800;
                    gameTime = 0;
                    startTimer();
                    timerValue.textContent = "03:00";
                    timerValue.classList.remove('timer-warning');
                } else if (currentChallenge === CHALLENGE_TYPES.SPRINT) {
                    dropInterval = 800;
                    startElapsedTimer();
                } else if (currentChallenge === CHALLENGE_TYPES.SURVIVAL) {
                    dropInterval = 800;
                    startElapsedTimer();
                    startSurvivalTimer();
                } else if (currentChallenge === CHALLENGE_TYPES.MARATHON) {
                    dropInterval = 800;
                    startElapsedTimer();
                    startMarathonTimer();
                } else {
                    dropInterval = 800;
                }
            }
            
            updateGameStatus('playing');
            updatePauseButton();
        }
        
        function startTimer() {
            if (gameTimer) clearInterval(gameTimer);
            
            gameTimer = setInterval(() => {
                if (!isPaused && !gameOver && gameStarted) {
                    gameTime += 1;
                    
                    const timeLeft = timeLimit - gameTime;
                    const minutes = Math.floor(timeLeft / 60);
                    const seconds = timeLeft % 60;
                    
                    timerValue.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    
                    if (timeLeft <= 30) {
                        timerValue.classList.add('timer-warning');
                    } else {
                        timerValue.classList.remove('timer-warning');
                    }
                    
                    if (timeLeft <= 0) {
                        endGame();
                    }
                }
            }, 1000);
        }
        
        function startElapsedTimer() {
            if (elapsedTimer) clearInterval(elapsedTimer);
            
            elapsedTimer = setInterval(() => {
                if (!isPaused && !gameOver && gameStarted) {
                    elapsedTime += 1;
                    
                    const minutes = Math.floor(elapsedTime / 60);
                    const seconds = elapsedTime % 60;
                    
                    timeElapsed.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }
        
        function startSurvivalTimer() {
            if (survivalGarbageInterval) clearInterval(survivalGarbageInterval);
            
            survivalGarbageInterval = setInterval(() => {
                if (!isPaused && !gameOver && gameStarted) {
                    survivalTimer -= 1;
                    
                    survivalTimerValue.textContent = `${survivalTimer} ${languageManager.getText('seconds')}`;
                    
                    if (survivalTimer <= 0) {
                        addGarbageLine();
                        survivalTimer = 30;
                        survivalTimerValue.textContent = `30 ${languageManager.getText('seconds')}`;
                    }
                }
            }, 1000);
        }
        
        // ============================
        // 优化版马拉松模式计时器函数（保留60秒检测）
        // ============================
        function startMarathonTimer() {
            if (marathonIncreaseInterval) clearInterval(marathonIncreaseInterval);
            
            marathonIncreaseInterval = setInterval(() => {
                if (!isPaused && !gameOver && gameStarted) {
                    marathonIncreaseTimer -= 1;
                    
                    updateMarathonTimerDisplay();
                    
                    if (marathonIncreaseTimer <= 0) {
                        increaseMarathonTarget();
                        marathonIncreaseTimer = 75;
                        updateMarathonTimerDisplay();
                    }
                }
            }, 1000);
            
            // 启动目标检测计时器
            if (marathonCheckInterval) clearInterval(marathonCheckInterval);
            
            marathonCheckInterval = setInterval(() => {
                if (!isPaused && !gameOver && gameStarted) {
                    marathonCheckTimer -= 1;
                    
                    // 更新马拉松进度显示中的检测计时器
                    marathonNextCheck.textContent = `${languageManager.getText('nextTargetCheck')}: ${marathonCheckTimer}秒`;
                    
                    if (marathonCheckTimer <= 0) {
                        checkMarathonTarget();
                        marathonCheckTimer = 60;
                        marathonNextCheck.textContent = `${languageManager.getText('nextTargetCheck')}: ${marathonCheckTimer}秒`;
                    }
                }
            }, 1000);
        }
        
        function stopMarathonTimer() {
            if (marathonIncreaseInterval) {
                clearInterval(marathonIncreaseInterval);
                marathonIncreaseInterval = null;
            }
            if (marathonCheckInterval) {
                clearInterval(marathonCheckInterval);
                marathonCheckInterval = null;
            }
        }
        
        function updateMarathonTimerDisplay() {
            marathonTimerValue.textContent = `${marathonIncreaseTimer} ${languageManager.getText('seconds')}`;
        }
        
        function updateMarathonDisplay() {
            marathonTargetElement.textContent = marathonTarget;
            marathonStageText.textContent = `已消除: ${marathonLinesCleared}/${marathonTarget}`;
            
            const progress = Math.min(100, Math.floor((marathonLinesCleared / marathonTarget) * 100));
            marathonProgressFill.style.width = `${progress}%`;
            
            updateMarathonTimerDisplay();
            marathonNextCheck.textContent = `${languageManager.getText('nextTargetCheck')}: ${marathonCheckTimer}秒`;
        }
        
        function increaseMarathonTarget() {
            marathonTarget += 10;
            marathonStage++;
            
            // 播放目标增加音效
            audioSystem.playSound('targetIncrease');
            
            // 显示目标增加特效
            const canvasX = canvas.offsetLeft + canvas.width / 2;
            const canvasY = canvas.offsetTop + canvas.height / 2;
            effectManager.createLineClearEffect(`目标增加!`, canvasX, canvasY, '#4CAF50');
            
            // 更新显示
            updateMarathonDisplay();
            
            // 目标增加奖励
            const increaseBonus = marathonStage * 200;
            score += increaseBonus;
            
            // 显示目标增加奖励
            const scoreX = canvas.offsetLeft + canvas.width - 100;
            const scoreY = canvas.offsetTop + 150;
            effectManager.createScoreAddEffect(increaseBonus, scoreX, scoreY, '#4CAF50');
            
            updateUI();
        }
        
        // 检查马拉松目标完成情况
        function checkMarathonTarget() {
            audioSystem.playSound('targetCheck');
            
            // 检查是否达到当前阶段目标
            if (marathonLinesCleared >= marathonTarget) {
                // 目标已达成，继续游戏
                // 显示目标达成特效
                const canvasX = canvas.offsetLeft + canvas.width / 2;
                const canvasY = canvas.offsetTop + canvas.height / 2;
                effectManager.createLineClearEffect(`目标达成!`, canvasX, canvasY, '#4CAF50');
                
                // 目标达成奖励
                const checkBonus = marathonStage * 100;
                score += checkBonus;
                
                // 显示目标达成奖励
                const scoreX = canvas.offsetLeft + canvas.width - 100;
                const scoreY = canvas.offsetTop + 200;
                effectManager.createScoreAddEffect(checkBonus, scoreX, scoreY, '#4CAF50');
                
                updateUI();
            } else {
                // 目标未达成，挑战失败
                marathonCheckFailed = true;
                endGame();
            }
        }
        
        function marathonComplete() {
            // 注意：这个函数现在不再被调用，因为取消了达到目标即可完成的机制
            // 保留函数以防其他代码调用
            endGame();
        }
        
        function stopTimer() {
            if (gameTimer) {
                clearInterval(gameTimer);
                gameTimer = null;
            }
        }
        
        function stopElapsedTimer() {
            if (elapsedTimer) {
                clearInterval(elapsedTimer);
                elapsedTimer = null;
            }
        }
        
        function stopSurvivalTimer() {
            if (survivalGarbageInterval) {
                clearInterval(survivalGarbageInterval);
                survivalGarbageInterval = null;
            }
        }
        
        function endGame() {
            gameOver = true;
            gameStarted = false;
            stopTimer();
            stopElapsedTimer();
            stopSurvivalTimer();
            stopMarathonTimer();
            
            audioSystem.playSound('gameover');
            
            gameOverlay.style.display = 'flex';
            startPrompt.style.display = 'block';
            
            let endMessage = '';
            let statusKey = 'gameover';
            
            if (currentMode === GAME_MODES.CHALLENGE && currentChallenge === CHALLENGE_TYPES.TIMED) {
                if (gameTime >= timeLimit) {
                    endMessage = `<h2>${languageManager.getText('timeup')}</h2><p>${languageManager.getText('challengeEnded')}</p><p>${languageManager.getText('pressSpaceToRestart')}</p>`;
                    statusKey = 'timeup';
                } else {
                    endMessage = `<h2>${languageManager.getText('challengeFailed')}</h2><p>${languageManager.getText('gameOver')}</p><p>${languageManager.getText('pressSpaceToRestart')}</p>`;
                }
            } else if (currentMode === GAME_MODES.CHALLENGE && currentChallenge === CHALLENGE_TYPES.MARATHON) {
                if (marathonCheckFailed) {
                    // 因未达到目标而失败
                    endMessage = `<h2>${languageManager.getText('targetNotReached')}</h2><p>${languageManager.getText('marathonFailed')}</p><p>${languageManager.getText('challengeFailed')}</p><p>${languageManager.getText('pressSpaceToRestart')}</p>`;
                } else if (marathonFailed) {
                    endMessage = `<h2>${languageManager.getText('marathonFailed')}</h2><p>${languageManager.getText('challengeFailed')}</p><p>${languageManager.getText('pressSpaceToRestart')}</p>`;
                } else {
                    endMessage = `<h2>${languageManager.getText('gameOver')}</h2><p>${languageManager.getText('pressSpaceToRestart')}</p>`;
                }
            } else {
                endMessage = `<h2>${languageManager.getText('gameOver')}</h2><p>${languageManager.getText('pressSpaceToRestart')}</p>`;
            }
            
            startPrompt.innerHTML = endMessage;
            
            // 使用正确的状态更新
            updateGameStatus(statusKey);
            
            if (score > 0) {
                setTimeout(() => {
                    pendingSaveScore = score;
                    let modalTitleText = languageManager.getText('gameOver');
                    let modalIcon = '🏆';
                    
                    if (currentMode === GAME_MODES.CHALLENGE) {
                        if (currentChallenge === CHALLENGE_TYPES.TIMED && gameTime >= timeLimit) {
                            modalTitleText = languageManager.getText('timeup');
                        } else if (currentChallenge === CHALLENGE_TYPES.TIMED) {
                            modalTitleText = languageManager.getText('challengeFailed');
                        } else if (currentChallenge === CHALLENGE_TYPES.MARATHON && marathonCheckFailed) {
                            modalTitleText = languageManager.getText('targetNotReached');
                        } else if (currentChallenge === CHALLENGE_TYPES.MARATHON && marathonFailed) {
                            modalTitleText = languageManager.getText('marathonFailed');
                        } else {
                            modalTitleText = languageManager.getText('challengeComplete');
                        }
                    }
                    
                    showCustomModal(
                        modalTitleText,
                        `${languageManager.getText('congratulations')} ${languageManager.getText('gameEnded')} ${languageManager.getText('enterNameToSave')}`,
                        score,
                        modalIcon
                    );
                }, 500);
            }
            
            updatePauseButton();
        }
        
        function gameLoop(time = 0) {
            const deltaTime = time - lastTime;
            lastTime = time;
            
            if (gameStarted && !isPaused && !gameOver) {
                dropCounter += deltaTime;
                if (dropCounter > dropInterval) {
                    movePiece(0, 1);
                    dropCounter = 0;
                }
            }
            
            drawBoard();
            drawNextPiece();
            
            requestAnimationFrame(gameLoop);
        }
        
        function handleKeyPress(event) {
            const gameKeys = [32, 37, 38, 39, 40, 80, 82];
            if (gameKeys.includes(event.keyCode)) {
                event.preventDefault();
            }
            
            if (event.keyCode === 32 && gameOver) {
                resetGame();
                startCountdown();
                return;
            }
            
            if (event.keyCode === 32 && !gameStarted && !isCountingDown && !gameOver) {
                startCountdown();
                return;
            }
            
            if (event.keyCode === 80) {
                if (gameStarted && !gameOver) {
                    togglePause();
                }
                return;
            }
            
            if (event.keyCode === 82) {
                resetGame();
                return;
            }
            
            if (!gameStarted || isPaused || gameOver) return;
            
            switch (event.keyCode) {
                case 37:
                    movePiece(-1, 0);
                    break;
                case 39:
                    movePiece(1, 0);
                    break;
                case 40:
                    movePiece(0, 1);
                    break;
                case 38:
                    if (rotatePiece(currentPiece)) {
                        audioSystem.playSound('rotate');
                    }
                    break;
                case 32:
                    hardDrop();
                    break;
            }
        }
        
        function togglePause() {
            if (!gameStarted || gameOver) return;
            
            isPaused = !isPaused;
            
            audioSystem.playSound('pause');
            
            if (isPaused) {
                stopTimer();
                stopElapsedTimer();
                stopSurvivalTimer();
                stopMarathonTimer();
                updateGameStatus('paused');
                bgmManager.pause();
            } else {
                if (currentChallenge === CHALLENGE_TYPES.TIMED && !gameOver) {
                    startTimer();
                }
                if (currentChallenge === CHALLENGE_TYPES.SPRINT || currentChallenge === CHALLENGE_TYPES.SURVIVAL || currentChallenge === CHALLENGE_TYPES.MARATHON) {
                    startElapsedTimer();
                }
                if (currentChallenge === CHALLENGE_TYPES.SURVIVAL) {
                    startSurvivalTimer();
                }
                if (currentChallenge === CHALLENGE_TYPES.MARATHON) {
                    startMarathonTimer();
                }
                updateGameStatus('playing');
                bgmManager.resume();
            }
            
            updatePauseButton();
        }
        
        function updatePauseButton() {
            if (!gameStarted || gameOver) {
                pauseBtn.disabled = true;
                pauseBtn.innerHTML = `⏸ ${languageManager.getText('pauseGame')} (P)`;
                pauseBtn.classList.remove('continue-btn');
            } else if (isPaused) {
                pauseBtn.disabled = false;
                pauseBtn.innerHTML = `▶ ${languageManager.getText('resume')} (P)`;
                pauseBtn.classList.add('continue-btn');
            } else {
                pauseBtn.disabled = false;
                pauseBtn.innerHTML = `⏸ ${languageManager.getText('pauseGame')} (P)`;
                pauseBtn.classList.remove('continue-btn');
            }
            
            resetBtn.disabled = !gameStarted && !gameOver;
        }
        
        function resetGame() {
            createBoard();
            currentPiece = createPiece();
            nextPiece = createPiece();
            updateNextPieceDisplay();
            
            score = 0;
            level = 1;
            lines = 0;
            gameTime = 0;
            elapsedTime = 0;
            sprintLinesCleared = 0;
            survivalTimer = 30;
            
            // 重置优化版马拉松模式变量
            marathonTarget = 10;
            marathonLinesCleared = 0;
            marathonIncreaseTimer = 75;
            marathonCheckTimer = 60;
            marathonStage = 1;
            marathonFailed = false;
            marathonCheckFailed = false;
            
            if (currentMode === GAME_MODES.CLASSIC) {
                dropInterval = 1000;
            } else if (currentMode === GAME_MODES.ENDLESS) {
                dropInterval = 800;
            } else if (currentMode === GAME_MODES.CHALLENGE) {
                if (currentChallenge === CHALLENGE_TYPES.TIMED) {
                    dropInterval = 800;
                } else if (currentChallenge === CHALLENGE_TYPES.SPRINT) {
                    dropInterval = 800;
                } else if (currentChallenge === CHALLENGE_TYPES.SURVIVAL) {
                    dropInterval = 800;
                } else if (currentChallenge === CHALLENGE_TYPES.MARATHON) {
                    dropInterval = 800;
                } else {
                    dropInterval = 800;
                }
            }
            
            gameOver = false;
            isPaused = false;
            gameStarted = false;
            stopTimer();
            stopCountdown();
            stopElapsedTimer();
            stopSurvivalTimer();
            stopMarathonTimer();
            
            gameOverlay.style.display = 'flex';
            startPrompt.style.display = 'block';
            startPrompt.innerHTML = `<h2>${languageManager.getText('getReady')}</h2><p>${languageManager.getText('pressSpaceToStart')}</p>`;
            countdownElement.style.display = 'none';
            
            updateUI();
            updateGameStatus('waiting');
            updatePauseButton();
        }
        
        function handleBackButton() {
            if (gameStarted && score > 0 && !gameOver) {
                showCustomModal(
                    languageManager.getText('saveScoreConfirm'),
                    languageManager.getText('saveScorePrompt'),
                    score,
                    '💾'
                );
                
                const originalClick = modalConfirmBtn.onclick;
                modalConfirmBtn.onclick = () => {
                    const playerName = modalInput.value.trim();
                    addScoreToLeaderboard(currentMode, playerName || languageManager.getText('anonymousPlayer'), score, currentChallenge);
                    hidePanel(customModal);
                    modalConfirmBtn.onclick = originalClick;
                    continueToPreviousMenu();
                };
                
                modalCancelBtn.onclick = () => {
                    hidePanel(customModal);
                    modalConfirmBtn.onclick = originalClick;
                    continueToPreviousMenu();
                };
            } else {
                continueToPreviousMenu();
            }
        }
        
        function continueToPreviousMenu() {
            loadSettings();
            
            if (currentMode === GAME_MODES.CHALLENGE && cameFromChallengeMenu) {
                challengeMenu.style.display = 'block';
                gameScreen.style.display = 'none';
                mainMenu.style.display = 'none';
                
                bgmManager.fadeOut(300);
                setTimeout(() => {
                    bgmManager.play('challenge_menu');
                    bgmManager.fadeIn(500);
                }, 350);
            } else {
                mainMenu.style.display = 'flex';
                challengeMenu.style.display = 'none';
                gameScreen.style.display = 'none';
                
                bgmManager.fadeOut(300);
                setTimeout(() => {
                    bgmManager.play('menu');
                    bgmManager.fadeIn(500);
                }, 350);
            }
            
            resetGame();
            updateSettingsButtonVisibility();
        }
        
        function showMainMenu() {
            cameFromChallengeMenu = false;
            loadSettings();
            
            mainMenu.style.display = 'flex';
            challengeMenu.style.display = 'none';
            gameScreen.style.display = 'none';
            
            bgmManager.fadeOut(300);
            setTimeout(() => {
                bgmManager.play('menu');
                bgmManager.fadeIn(500);
            }, 350);
            
            resetGame();
            updateSettingsButtonVisibility();
        }
        
        function updateNextPieceDisplay() {
            if (nextPiece) {
                const pieceKey = `piece${nextPiece.id}`;
                nextPieceElement.textContent = languageManager.getText(pieceKey);
                drawNextPiece();
            }
        }
        
        function updateGameStatus(status) {
            let statusText = '';
            let statusClass = '';
            
            // 直接使用languageManager.getText获取文本
            switch (status) {
                case 'waiting':
                    statusText = languageManager.getText('waitingToStart');
                    statusClass = 'status-ready';
                    break;
                case 'playing':
                    statusText = languageManager.getText('playing');
                    statusClass = 'status-playing';
                    break;
                case 'paused':
                    statusText = languageManager.getText('paused');
                    statusClass = 'status-paused';
                    break;
                case 'gameover':
                    statusText = languageManager.getText('gameOver');
                    statusClass = 'status-gameover';
                    break;
                case 'timeup':
                    statusText = languageManager.getText('timeup');
                    statusClass = 'status-gameover';
                    break;
            }
            
            gameStatusElement.textContent = statusText;
            gameStatusElement.className = `game-status ${statusClass}`;
        }
        
        function updateGameStatusText() {
            const currentClass = gameStatusElement.className;
            if (currentClass.includes('status-ready')) {
                gameStatusElement.textContent = languageManager.getText('waitingToStart');
            } else if (currentClass.includes('status-playing')) {
                gameStatusElement.textContent = languageManager.getText('playing');
            } else if (currentClass.includes('status-paused')) {
                gameStatusElement.textContent = languageManager.getText('paused');
            } else if (currentClass.includes('status-gameover')) {
                gameStatusElement.textContent = languageManager.getText('gameOver');
            }
        }
        
        function updateUI() {
            scoreElement.textContent = score;
            levelElement.textContent = level;
            linesElement.textContent = lines;
            timeElapsed.textContent = "00:00";
        }
        
        function showPanel(panel) {
            panel.style.display = 'flex';
        }
        
        function hidePanel(panel) {
            panel.style.display = 'none';
        }
        
        // ============================
        // 排行榜系统
        // ============================
        function loadLeaderboardData() {
            const savedData = localStorage.getItem('tetrisLeaderboard');
            if (savedData) {
                try {
                    leaderboardData = JSON.parse(savedData);
                    if (!leaderboardData.classic) leaderboardData.classic = [];
                    if (!leaderboardData.challenge) leaderboardData.challenge = [];
                    if (!leaderboardData.endless) leaderboardData.endless = [];
                } catch (e) {
                    console.error('加载排行榜数据失败:', e);
                    leaderboardData = {
                        classic: [],
                        challenge: [],
                        endless: []
                    };
                }
            }
        }
        
        function saveLeaderboardData() {
            try {
                localStorage.setItem('tetrisLeaderboard', JSON.stringify(leaderboardData));
                return true;
            } catch (e) {
                console.error('保存排行榜数据失败:', e);
                return false;
            }
        }
        
        function addScoreToLeaderboard(mode, playerName, score, challengeType = null) {
            if (!mode || !playerName || score === undefined || score === null) {
                showSaveNotification('❌ ' + languageManager.getText('saveScore') + languageManager.getText('failed'), true);
                return false;
            }
            
            if (!leaderboardData[mode]) {
                leaderboardData[mode] = [];
            }
            
            const newScore = {
                name: playerName.trim() || languageManager.getText('anonymousPlayer'),
                score: parseInt(score),
                date: new Date().toLocaleDateString(languageManager.currentLang),
                timestamp: Date.now(),
                challengeType: challengeType
            };
            
            if (challengeType === CHALLENGE_TYPES.SPRINT) {
                newScore.time = elapsedTime;
            }
            if (challengeType === CHALLENGE_TYPES.SURVIVAL) {
                newScore.survivalTime = elapsedTime;
            }
            if (challengeType === CHALLENGE_TYPES.MARATHON) {
                newScore.marathonLines = marathonLinesCleared;
                newScore.marathonStages = marathonStage - 1;
                newScore.marathonCheckFailed = marathonCheckFailed;
            }
            
            if (isNaN(newScore.score) || newScore.score <= 0) {
                showSaveNotification('❌ ' + languageManager.getText('saveScore') + languageManager.getText('failed'), true);
                return false;
            }
            
            leaderboardData[mode].push(newScore);
            leaderboardData[mode].sort((a, b) => b.score - a.score || a.timestamp - b.timestamp);
            
            if (leaderboardData[mode].length > 10) {
                leaderboardData[mode] = leaderboardData[mode].slice(0, 10);
            }
            
            const success = saveLeaderboardData();
            
            if (success) {
                const savedText = languageManager.getText('scoreSaved');
                showSaveNotification(`🎯 ${savedText}`);
                updateLeaderboardDisplay();
                return true;
            } else {
                showSaveNotification('❌ ' + languageManager.getText('saveScore') + languageManager.getText('failed'), true);
                return false;
            }
        }
        
        function updateLeaderboardDisplay() {
            updateLeaderboardList('classic', classicLeaderboard);
            updateLeaderboardList('challenge', challengeLeaderboard);
            updateLeaderboardList('endless', endlessLeaderboard);
        }
        
        function updateLeaderboardList(mode, listElement) {
            const scores = leaderboardData[mode] || [];
            
            if (scores.length === 0) {
                listElement.innerHTML = `
                    <div class="no-scores">
                        <div style="font-size: 3rem; margin-bottom: 10px;">📊</div>
                        <div>${languageManager.getText('noScores')}</div>
                        <div style="font-size: 0.8rem; margin-top: 10px; color: #666;">
                            ${languageManager.getText('beTheFirst')}
                        </div>
                    </div>
                `;
                return;
            }
            
            let html = '';
            scores.forEach((score, index) => {
                const rank = index + 1;
                let rankClass = '';
                if (rank === 1) rankClass = '🥇';
                else if (rank === 2) rankClass = '🥈';
                else if (rank === 3) rankClass = '🥉';
                
                let challengeInfo = '';
                if (mode === 'challenge' && score.challengeType) {
                    const challengeName = getChallengeName(score.challengeType);
                    
                    if (score.challengeType === CHALLENGE_TYPES.SPRINT && score.time) {
                        const minutes = Math.floor(score.time / 60);
                        const seconds = Math.floor(score.time % 60);
                        const timeFormatted = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                        challengeInfo = `<div class="leaderboard-date">${challengeName} - ${languageManager.getText('timeUsed')} ${timeFormatted} | ${score.date}</div>`;
                    } else if (score.challengeType === CHALLENGE_TYPES.SURVIVAL && score.survivalTime) {
                        const minutes = Math.floor(score.survivalTime / 60);
                        const seconds = Math.floor(score.survivalTime % 60);
                        const timeFormatted = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                        challengeInfo = `<div class="leaderboard-date">${challengeName} - ${languageManager.getText('survivalTime')} ${timeFormatted} | ${score.date}</div>`;
                    } else if (score.challengeType === CHALLENGE_TYPES.MARATHON && score.marathonLines) {
                        const status = score.marathonCheckFailed ? languageManager.getText('targetNotReached') : languageManager.getText('marathonComplete');
                        challengeInfo = `<div class="leaderboard-date">${challengeName} - ${status} - ${languageManager.getText('totalLines')} ${score.marathonLines} | ${score.date}</div>`;
                    } else {
                        challengeInfo = `<div class="leaderboard-date">${challengeName} | ${score.date}</div>`;
                    }
                } else {
                    challengeInfo = `<div class="leaderboard-date">${score.date}</div>`;
                }
                
                const formattedScore = score.score.toLocaleString(languageManager.currentLang);
                
                html += `
                    <div class="leaderboard-item">
                        <div class="leaderboard-rank">${rankClass || rank}</div>
                        <div class="leaderboard-info">
                            <div class="leaderboard-name">${score.name}</div>
                            <div class="leaderboard-score">${languageManager.getText('score')}: ${formattedScore}</div>
                            ${challengeInfo}
                        </div>
                    </div>
                `;
            });
            
            listElement.innerHTML = html;
        }
        
        function getChallengeName(challengeType) {
            switch(challengeType) {
                case CHALLENGE_TYPES.TIMED: return languageManager.getText('timedChallenge');
                case CHALLENGE_TYPES.INVISIBLE: return languageManager.getText('invisibleMode');
                case CHALLENGE_TYPES.INVISIBLE2: return languageManager.getText('invisible2Mode');
                case CHALLENGE_TYPES.SPRINT: return languageManager.getText('sprint40');
                case CHALLENGE_TYPES.SURVIVAL: return languageManager.getText('survivalMode');
                case CHALLENGE_TYPES.MARATHON: return languageManager.getText('marathonMode');
                default: return languageManager.getText('challengeMode');
            }
        }
        
        function getModeName(mode) {
            switch(mode) {
                case 'classic': return languageManager.getText('classicMode');
                case 'challenge': return languageManager.getText('challengeMode');
                case 'endless': return languageManager.getText('endlessMode');
                default: return languageManager.getText('unknownMode');
            }
        }
        
        function switchLeaderboardTab(mode) {
            leaderboardTabs.forEach(tab => {
                if (tab.getAttribute('data-mode') === mode) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });
            
            classicLeaderboard.style.display = mode === 'classic' ? 'block' : 'none';
            challengeLeaderboard.style.display = mode === 'challenge' ? 'block' : 'none';
            endlessLeaderboard.style.display = mode === 'endless' ? 'block' : 'none';
        }
        
        // ============================
        // 自定义弹窗
        // ============================
        function initCustomModal() {
            modalCancelBtn.addEventListener('click', () => {
                hidePanel(customModal);
                modalInput.value = '';
                modalInput.style.display = '';
                modalScore.style.display = '';
                modalConfirmBtn.className = 'custom-modal-btn custom-modal-btn-primary';
                modalConfirmBtn.textContent = languageManager.getText('save');
                audioSystem.playSound('click');
            });
            
            modalConfirmBtn.addEventListener('click', () => {
                const playerName = modalInput.value.trim();
                if (pendingSaveScore !== null) {
                    addScoreToLeaderboard(currentMode, playerName || languageManager.getText('anonymousPlayer'), pendingSaveScore, currentChallenge);
                    pendingSaveScore = null;
                }
                hidePanel(customModal);
                modalInput.value = '';
                modalInput.style.display = '';
                modalScore.style.display = '';
                modalConfirmBtn.className = 'custom-modal-btn custom-modal-btn-primary';
                modalConfirmBtn.textContent = languageManager.getText('save');
                audioSystem.playSound('click');
            });
            
            modalInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    modalConfirmBtn.click();
                }
            });
        }
        
        function showCustomModal(title, text, score, icon = '📝') {
            modalIcon.textContent = icon;
            modalTitle.textContent = title;
            modalText.textContent = text;
            modalScore.textContent = score ? languageManager.getText('currentScore') + score.toLocaleString() : '';
            modalInput.value = '';
            modalInput.style.display = 'block';
            modalScore.style.display = 'block';
            modalInput.focus();
            
            modalConfirmBtn.className = 'custom-modal-btn custom-modal-btn-primary';
            modalConfirmBtn.textContent = languageManager.getText('save');
            
            showPanel(customModal);
        }
        
        function showClearLeaderboardConfirm() {
            const activeTab = document.querySelector('.leaderboard-tab.active');
            const mode = activeTab.getAttribute('data-mode');
            const modeName = getModeName(mode);
            
            modalIcon.textContent = '🗑️';
            modalTitle.textContent = languageManager.getText('clearConfirmTitle');
            modalText.textContent = languageManager.getText('clearConfirmText');
            modalScore.textContent = '';
            modalInput.style.display = 'none';
            modalScore.style.display = 'none';
            
            modalConfirmBtn.className = 'custom-modal-btn custom-modal-btn-danger';
            modalConfirmBtn.textContent = languageManager.getText('delete');
            
            showPanel(customModal);
            
            const originalClick = modalConfirmBtn.onclick;
            modalConfirmBtn.onclick = () => {
                leaderboardData[mode] = [];
                const success = saveLeaderboardData();
                
                if (success) {
                    showSaveNotification(`✅ ${languageManager.getText('clearSuccess')}`);
                    updateLeaderboardDisplay();
                } else {
                    showSaveNotification('❌ ' + languageManager.getText('clearScores') + languageManager.getText('failed'), true);
                }
                
                hidePanel(customModal);
                modalConfirmBtn.className = 'custom-modal-btn custom-modal-btn-primary';
                modalConfirmBtn.textContent = languageManager.getText('save');
                modalConfirmBtn.onclick = originalClick;
                audioSystem.playSound('click');
            };
            
            modalCancelBtn.onclick = () => {
                hidePanel(customModal);
                modalInput.style.display = '';
                modalScore.style.display = '';
                modalConfirmBtn.className = 'custom-modal-btn custom-modal-btn-primary';
                modalConfirmBtn.textContent = languageManager.getText('save');
                audioSystem.playSound('click');
            };
        }
        
        function showSaveNotification(message, isError = false) {
            saveNotification.innerHTML = `<span>${message}</span>`;
            saveNotification.className = `save-notification ${isError ? 'error' : ''}`;
            saveNotification.style.display = 'flex';
            
            saveNotification.style.animation = 'none';
            setTimeout(() => {
                saveNotification.style.animation = 'slideDown 0.3s ease, fadeOut 0.3s ease 2.7s forwards';
            }, 10);
            
            setTimeout(() => {
                saveNotification.style.display = 'none';
            }, 3000);
        }
        
        // ============================
        // 版本更新系统
        // ============================
        function initVersionList() {
            versionSidebar.innerHTML = '';
            
            VERSION_DATA.forEach((version, index) => {
                const versionItem = document.createElement('div');
                versionItem.className = `version-item ${version.current ? 'current-version' : ''}`;
                if (index === 0) versionItem.classList.add('active');
                
                versionItem.innerHTML = `
                    <div class="version-number">v${version.version}</div>
                    <div class="version-date-sidebar">${version.date}</div>
                `;
                
                versionItem.addEventListener('click', () => {
                    document.querySelectorAll('.version-item').forEach(item => {
                        item.classList.remove('active');
                    });
                    versionItem.classList.add('active');
                    showVersionDetail(version);
                    audioSystem.playSound('click');
                });
                
                versionSidebar.appendChild(versionItem);
            });
            
            if (VERSION_DATA.length > 0) {
                showVersionDetail(VERSION_DATA[0]);
            }
        }
        
        function showVersionDetail(version) {
            let title = version.title;
            let description = version.description;
            let features = version.features;
            
            const currentLang = languageManager.currentLang;
            
            detailTitle.textContent = title;
            detailSubtitle.textContent = `${languageManager.getText('version')} ${version.version} - ${version.date}`;
            
            const featuresHtml = features.map(feature => `<li>${feature}</li>`).join('');
            
            versionDetailContent.innerHTML = `
                <h2 class="version-title">${title}</h2>
                <div class="version-meta">
                    <div class="version-number-large">${languageManager.getText('version')} ${version.version}</div>
                    <div class="version-date-detail">${version.date}</div>
                </div>
                <p class="version-description">${description}</p>
                <ul class="version-features">${featuresHtml}</ul>
            `;
            
            versionDetailContent.scrollTop = 0;
        }
        
        // ============================
        // 启动游戏
        // ============================
        window.onload = init;
        window.languageManager = languageManager;
        window.updateNextPieceDisplay = updateNextPieceDisplay;
        window.updateGameStatus = updateGameStatus;
        window.updateMarathonTimerDisplay = updateMarathonTimerDisplay;
        window.updateMarathonDisplay = updateMarathonDisplay;
    </script>
</body>
</html>